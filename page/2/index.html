<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"2298233831.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="The Blog of Yu4n">
<meta property="og:url" content="http://2298233831.github.io/page/2/index.html">
<meta property="og:site_name" content="The Blog of Yu4n">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yu4n">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://2298233831.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>The Blog of Yu4n</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">The Blog of Yu4n</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2298233831.github.io/2022/04/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yu4n">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Blog of Yu4n">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">逆向工程核心原理_反调试技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-12 15:54:48 / 修改时间：18:11:23" itemprop="dateCreated datePublished" datetime="2022-04-12T15:54:48+08:00">2022-04-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="反调试技术"><a href="#反调试技术" class="headerlink" title="反调试技术"></a>反调试技术</h1><p>在开始前，先用一张图简要说明反调试技术的种类</p>
<p><img src="/2022/04/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/image-20220412122021162.png" alt="image-20220412122021162"></p>
<h1 id="静态反调试"><a href="#静态反调试" class="headerlink" title="静态反调试"></a>静态反调试</h1><p>承接之前学习的PEB结构体，该结构体的成员主要有以下四个更值得关注，且都与反调试有关。</p>
<p><img src="/2022/04/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/image-20220412122133677.png" alt="image-20220412122133677"></p>
<p>首先复习下如何访问PEB结构体</p>
<p><img src="/2022/04/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/image-20220412122227236.png" alt="image-20220412122227236"></p>
<p>利用上面的方式再加上上面四个成员的偏移量就可以访问对应的成员了。</p>
<h2 id="BeingDebugged"><a href="#BeingDebugged" class="headerlink" title="BeingDebugged"></a>BeingDebugged</h2><p>该成员在值为1是表示进程处在调试状态，为0则正常运行。</p>
<h2 id="Ldr"><a href="#Ldr" class="headerlink" title="Ldr"></a>Ldr</h2><p>在进程处于调试状态的堆区中，未使用的内存区域全部由0xFEEEFEEE填充，若将其用NULL覆盖即表明程序处于正常运行状态。</p>
<h2 id="Process-Heap"><a href="#Process-Heap" class="headerlink" title="Process Heap"></a>Process Heap</h2><p>该成员是指向Heap结构体的指针</p>
<p><img src="/2022/04/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/image-20220412122817083.png" alt="image-20220412122817083"></p>
<p>其中，在正常运行时，Flags和Force Flags成员会被设置为特定的值，分别为0x2,0x0</p>
<h2 id="NtGlobalFlag"><a href="#NtGlobalFlag" class="headerlink" title="NtGlobalFlag"></a>NtGlobalFlag</h2><p>调试状态时该成员的值会被设置为0x70，正常运行状态则值为0.</p>
<h2 id="NtQueryInformationProcess"><a href="#NtQueryInformationProcess" class="headerlink" title="NtQueryInformationProcess"></a>NtQueryInformationProcess</h2><p><img src="/2022/04/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/image-20220412141513488.png" alt="image-20220412141513488"></p>
<p><img src="/2022/04/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/image-20220412141652792.png" alt="image-20220412141652792"></p>
<p>此处的例子出于将会多次涉及参数数值的更改，会很麻烦，所以涉及api hook，</p>
<h2 id="NtQureyObject"><a href="#NtQureyObject" class="headerlink" title="NtQureyObject"></a>NtQureyObject</h2><p>首先，当进程处于调试状态时，系统会分配一个调试对象类型的内核对象，通过检测该对象是否存在，即可判断是否处于调试状态。</p>
<p>简要说明检测过程：</p>
<p>通过NtQureyObject()api获取系统各种内核对象的信息。定义如下</p>
<p><img src="/2022/04/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/image-20220412143047207.png" alt="image-20220412143047207"></p>
<p>通过书中的调试案例可更快理解该反调试的具体过程</p>
<h2 id="ZwSetInformationThread"><a href="#ZwSetInformationThread" class="headerlink" title="ZwSetInformationThread"></a>ZwSetInformationThread</h2><p>该api会将线程隐藏，调试器无法接受信息，从而无法调试。</p>
<p>可以让该api不调用，可以解决问题，或者在调用该api之前，将存储在栈中的的第二个参数ThreadInformationClass的值设置为0即可。</p>
<h2 id="and-so-on"><a href="#and-so-on" class="headerlink" title="and so on"></a>and so on</h2><p>再者就是之前介绍过的TLS回调函数实现反调试了，很经典。</p>
<p>书中最后还介绍了一种通过检测程序运行所处的系统是否为你想专用的系统来决定是否实现反调试。</p>
<p><img src="/2022/04/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/image-20220412144545994.png" alt="image-20220412144545994"></p>
<h1 id="动态反调试技术"><a href="#动态反调试技术" class="headerlink" title="动态反调试技术"></a>动态反调试技术</h1><p>异常是常被用来实现动态反调试的手段之一。本章前面所描述的部分内容可在SEH那章找到。</p>
<p>而当进程中未注册SEH或SEH未处理异常时</p>
<p><img src="/2022/04/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/image-20220412144910002.png" alt="image-20220412144910002"></p>
<h2 id="Timing-Check"><a href="#Timing-Check" class="headerlink" title="Timing Check"></a>Timing Check</h2><p>原理为当程序在正常运行时和调试时所耗费的时间不同来检测进程是否处于调试状态。</p>
<p>如下是检测方法</p>
<p><img src="/2022/04/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/image-20220412145143458.png" alt="image-20220412145143458"></p>
<p>RDTSC反调试的破解方式如图</p>
<p><img src="/2022/04/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/image-20220412145402293.png" alt="image-20220412145402293"></p>
<p><img src="/2022/04/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/image-20220412145410760.png" alt="image-20220412145410760"></p>
<h2 id="TF与单步"><a href="#TF与单步" class="headerlink" title="TF与单步"></a>TF与单步</h2><p><img src="/2022/04/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/image-20220412145445431.png" alt="image-20220412145445431"></p>
<p>前面的章节提到，Windows中存在单步异常。</p>
<p>在单步执行模式中，该异常触发后，TF会自动清零</p>
<p>需要注意TF的值无法修改</p>
<p>大体流程如下</p>
<p><img src="/2022/04/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/image-20220412145859419.png" alt="image-20220412145859419"></p>
<p>调试例子可以通过将-1修改为0x401036的值也可绕过反调试。</p>
<p><img src="/2022/04/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/image-20220412150430023.png" alt="image-20220412150430023"></p>
<h2 id="INT-2D"><a href="#INT-2D" class="headerlink" title="INT 2D"></a>INT 2D</h2><p>该异常比较有意思，在调试状态时，解析了该指令后，系统会忽略下一条指令的第一个字节，导致之后指令解析错误。</p>
<p>跟着例子调一下就明白了。</p>
<h2 id="0xCC探测"><a href="#0xCC探测" class="headerlink" title="0xCC探测"></a>0xCC探测</h2><p>断点对应的x86指令为0xCC</p>
<p>如果只是扫面0xCC就判断在调试状态，那大概率会“误伤”</p>
<p>故一般会检测一些API函数的第一个字节是否0xCC，所以尽量别在API函数开头设置软件断点，往后一点，或者设置硬件断点即可规避该反调试手段。</p>
<h2 id="比较校验和"><a href="#比较校验和" class="headerlink" title="比较校验和"></a>比较校验和</h2><p>程序中如若设置了断电会导致校验和的值不相同，具体可结合书中实例查看</p>
<p>我们只需不在会被计算校验和的代码区设置断点即可规避</p>
<h1 id="高级逆向分析技术"><a href="#高级逆向分析技术" class="headerlink" title="高级逆向分析技术"></a>高级逆向分析技术</h1><ol>
<li>垃圾代码（花指令）</li>
<li>扰乱代码对齐（向代码插入经过精巧设计的不必要的代码来降低反汇编代码可读性），该方法会使调试器生成错误的反汇编代码，具体请阅读书籍。</li>
<li>对关键数据和代码加解密（此中可能会参杂花指令使可读性降低）</li>
<li>Stolen Bytes（在转储进程内存时将EP代码的部分剪切到其他地方，从而使转储的文件无法正常运行反转储技术，被剪切的代码最后会添加jmp指令跳转到还存在的EP代码继续执行）</li>
<li>API重定向；这跟上面那个差不多，API重定向是把所有EP代码都复制到其他区域，再将要保护的代码修改，从而使被复制的代码得以执行（该技术支持反转储）</li>
</ol>
<p>最后的</p>
<p><img src="/2022/04/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/image-20220412155347155.png" alt="image-20220412155347155"></p>
<h1 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h1><p>这几章的内容都很注重实操，不应该停留在阅读理解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2298233831.github.io/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yu4n">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Blog of Yu4n">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">逆向工程核心原理_高级逆向分析技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-11 08:55:19 / 修改时间：09:03:44" itemprop="dateCreated datePublished" datetime="2022-04-11T08:55:19+08:00">2022-04-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TLS-Thread-Local-Storage-回调函数"><a href="#TLS-Thread-Local-Storage-回调函数" class="headerlink" title="TLS(Thread Local Storage)回调函数"></a>TLS(Thread Local Storage)回调函数</h1><p>首先需要注意的一点就是，TLS回调函数是在程序进入OEP之前调用的，因此利用这一特性可以在此设置反调试。</p>
<p>简要说明TLS定义:TLS是各线程的独立的数据存储空间，使用TLS技术可在线程内部独立使用或修改进程的全局数据或静态数据，就像对待自身的局部变量一样。</p>
<p>那么TLS回调函数是指</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220409084748247.png" alt="image-20220409084748247"></p>
<p>值得一提的是，TLS表是需要在编程中开启TLS功能才会被设置在PE头文件中</p>
<p>IMAGE_TLS_DIRECTORY结构体有两种版本，32位和64位。</p>
<p>AddressOfCallBacks： 指向TLS注册的回调函数的函数指针(地址)数组（这个逆向时就很重要了）</p>
<p>通过TLS回调函数和DLLmain的定义比较可以发现，二者是类似的</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220409085002301.png" alt="image-20220409085002301"></p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220409085011556.png" alt="image-20220409085011556"></p>
<p>上述图一中，reason是指调用TLS函数的原因</p>
<p>如图所示</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220409085140790.png" alt="image-20220409085140790"></p>
<p>分别是DLL进程&#x2F;线程附加；DLL进程&#x2F;线程分离</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220409182903022.png" alt="image-20220409182903022"></p>
<p>关于调试TLS函数和手动添加TLS函数此处不在描述，过程中涉及对PE文件结构知识的回顾，重在实践。</p>
<h1 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h1><p>贴上书中的定义</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410113647863.png" alt="image-20220410113647863"></p>
<p>丛书中的描述可知，TEB结构体的成员多而复杂，但在用户模式调试中起重要作用的成员有两个</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410113850420.png" alt="image-20220410113850420"></p>
<p>先看ProcessEnvironmentBlock，它是指向PEB—进程环境块结构体的指针.每个进程对应一个PEB结构体</p>
<p>再看NtTib成员，TEB结构体的第一个成员为_NT_TIB（Thread Information Block—线程信息块）结构体</p>
<p>下图为其结构体定义</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410114802311.png" alt="image-20220410114802311"></p>
<p>self成员为该结构体的自引用指针，同时因为该结构体为TEB的第一个结构体成员，所以它同时也是指向TEB结构体的指针。</p>
<h2 id="TEB访问方法（用户模式下）"><a href="#TEB访问方法（用户模式下）" class="headerlink" title="TEB访问方法（用户模式下）"></a>TEB访问方法（用户模式下）</h2><p>这里对FS段寄存器做了说明</p>
<p>原文解释的很清楚</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410120445854.png" alt="image-20220410120445854"></p>
<p>由上可知，FS实际存储的是SDT的索引</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410120647654.png" alt="image-20220410120647654"></p>
<h1 id="PEB-进程环境块"><a href="#PEB-进程环境块" class="headerlink" title="PEB(进程环境块)"></a>PEB(进程环境块)</h1><p>PEB是存放进程信息的结构体</p>
<p>根据PEB结构体地址我们可以用如下方式访问PEB结构体</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410121548028.png" alt="image-20220410121548028"></p>
<h2 id="PEB的重要成员"><a href="#PEB的重要成员" class="headerlink" title="PEB的重要成员"></a>PEB的重要成员</h2><p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410121808724.png" alt="image-20220410121808724"></p>
<p>先看第一个成员，顾名思义，用来检测当前进程是否处于调试状态，是则返回1，否则返回0.</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410122356393.png" alt="image-20220410122356393"></p>
<p>可以看到该API就是通过调用该成员实现检测当前进程是否处于调试状态。</p>
<p>接下来是第二个成员</p>
<p>该进程用来获取进程的ImageBase</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410122602024.png" alt="image-20220410122602024"></p>
<p>上图的API用来获取ImageBase，实现方法与上一个API类似。</p>
<p>再下一个Ldr，该成员是指向PEB_LDR_DATA结构体的指针，结构体成员如下图所示</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410122801231.png" alt="image-20220410122801231"></p>
<p>该成员可直接获取加载到进程的DLL模块的加载基地址</p>
<p>可以看到结构体中有三个_LIST_ENTRY类型的成员。，该结构体定义如下图</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410123646015.png" alt="image-20220410123646015"></p>
<p>最后两个成员都应用于反调试技术。进程处于调试状态时，有特定值。</p>
<h1 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h1><p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410151204978.png" alt="image-20220410151204978"></p>
<p>SEH机制在程序源代码中使用try,except,finally关键字来实现。</p>
<p>书中第一个例子的异常触发是由于访问未分配的内存。</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410162947013.png" alt="image-20220410162947013"></p>
<p>操作系统的异常处理方法大致可根据程序运行情况分为两大类</p>
<ol>
<li>正常运行时处理</li>
<li>调试运行时处理</li>
</ol>
<p>第一种操作系统会将异常交给进程处理，若进程代码有相应的解决代码，则顺利处理，否则终止进程运行。</p>
<p>第二种则是交给调试器处理。调试器的权限很多，除了与被调试的进程有几乎一样的权限外，还有被调试者的虚拟内存，寄存器的读写权限。在遇到异常时，调试器会暂停运行，异常处理完后继续调试</p>
<p>下图为几种处理方法</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410165322561.png" alt="image-20220410165322561"></p>
<p>一下是操作系统所定义的—异常</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410165654556.png" alt="image-20220410165654556"></p>
<p>书中着重讨论了5种</p>
<h2 id="EXCEPTION-ACCESS-VIOLATION（C0000005）"><a href="#EXCEPTION-ACCESS-VIOLATION（C0000005）" class="headerlink" title="EXCEPTION_ACCESS_VIOLATION（C0000005）"></a>EXCEPTION_ACCESS_VIOLATION（C0000005）</h2><p>这就是访问不存在或不具访问权限的内存区域是所触发的异常—非法访问异常（最常见）</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410170337983.png" alt="image-20220410170337983"></p>
<h2 id="EXCEPTION-BREAKPOINT-80000003"><a href="#EXCEPTION-BREAKPOINT-80000003" class="headerlink" title="EXCEPTION_BREAKPOINT(80000003)"></a>EXCEPTION_BREAKPOINT(80000003)</h2><p>这就是调试器实现断点的原理，CPU遇到被设置了断点的代码会暂停运行。</p>
<p>实现方法：</p>
<p>​    INT3为设置断点命令的汇编语言，所对应的机器码为0xCC。CPU若遇到了该指令，即触发该异常</p>
<h2 id="EXCEPTION-ILLEGAL-INSTRUCTION-C000001D"><a href="#EXCEPTION-ILLEGAL-INSTRUCTION-C000001D" class="headerlink" title="EXCEPTION_ILLEGAL_INSTRUCTION(C000001D)"></a>EXCEPTION_ILLEGAL_INSTRUCTION(C000001D)</h2><p>CPU遇到无法解析（在该CPU架构下未定义）的指令时触发异常</p>
<h2 id="EXCEPTION-INT-DIVIDE-BY-ZERO-C0000094"><a href="#EXCEPTION-INT-DIVIDE-BY-ZERO-C0000094" class="headerlink" title="EXCEPTION_INT_DIVIDE_BY_ZERO(C0000094)"></a>EXCEPTION_INT_DIVIDE_BY_ZERO(C0000094)</h2><p>小学数学经典错误，整数除法当中，分母为0.当然，若分母为某个变量，变量在某个时刻为0，也会触发该异常</p>
<p>。比如一个变量自己跟自己异或，返回0</p>
<h2 id="EXCEPTION-SINGLE-STEP"><a href="#EXCEPTION-SINGLE-STEP" class="headerlink" title="EXCEPTION_SINGLE_STEP"></a>EXCEPTION_SINGLE_STEP</h2><p>单步过后程序暂停，程序进入单步模式后，每执行一次单步，就触发一次该异常。</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410172513951.png" alt="image-20220410172513951"></p>
<h2 id="SEH链"><a href="#SEH链" class="headerlink" title="SEH链"></a>SEH链</h2><p>原图简洁明了</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410172810751.png" alt="image-20220410172810751"></p>
<h2 id="异常处理函数的定义"><a href="#异常处理函数的定义" class="headerlink" title="异常处理函数的定义"></a>异常处理函数的定义</h2><p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410172842993.png" alt="image-20220410172842993"></p>
<p>该函数传入四个参数,返回一个枚举类型.四个参数都保存异常的相关信息,第三个参数是指向CONTEXT结构体的指针.</p>
<p>该结构体的定义如下</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410180000470.png" alt="image-20220410180000470"></p>
<p>该结构体用来备份CPU寄存器的值(多线程环境下需要).每个线程内部都拥有一个CONTEXT结构体,当CPU暂时离开当前线程去执行其他线程时,CPU寄存器的值就会保存到当前的CONTEXT结构体中,再次运行该线程时,就会用保存的值覆盖寄存器的值,从之前暂停的代码处继续执行.正是因此,OS才可以在多线程下安全运行各线程.</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410180451097.png" alt="image-20220410180451097"></p>
<p>所返回的枚举类型如下</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410183502324.png" alt="image-20220410183502324"></p>
<p>在异常发生时执行异常代码的线程会被中断运行,转而运行SEH,OS会把线程的CONTEXT结构体指针传递给异常处理函数的相应参数.</p>
<p>第一个成员是一个结构体,其定义如下</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410174054428.png" alt="image-20220410174054428"></p>
<p>其中,第一个成员用来指出异常类型;第四个则用来表示发生异常的代码地址.</p>
<p>TEB结构体的第一个成员是TEB.NtTib.ExceptionList,通过它可以很容易地访问进程的SEH链.</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410185707466.png" alt="image-20220410185707466"></p>
<p>SEH安装方法</p>
<p><img src="/2022/04/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%AB%98%E7%BA%A7%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/image-20220410185822888.png" alt="image-20220410185822888"></p>
<p>后面的调试建议动手调，没有什么需要特别说明的。</p>
<p>关于IA32指令解析，就像是在教你如何查阅程序员的字典一样，跟着阅读即可。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2298233831.github.io/2022/03/25/IL2CPP%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yu4n">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Blog of Yu4n">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/25/IL2CPP%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">IL2CPP学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-25 17:29:09 / 修改时间：18:01:13" itemprop="dateCreated datePublished" datetime="2022-03-25T17:29:09+08:00">2022-03-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="IL2CPP"><a href="#IL2CPP" class="headerlink" title="IL2CPP"></a>IL2CPP</h1><h2 id="IL2CPP是什么"><a href="#IL2CPP是什么" class="headerlink" title="IL2CPP是什么"></a>IL2CPP是什么</h2><p>首先我们来了解一下它的前缀，IL (Intermediate Language-中间语言)—基于堆栈的伪汇编语言；很多时候还会看到CIL（Common Intermediate Language，特指在.Net平台下的IL标准）。这两者是属于通用语言架构和.NET框架的低阶的人类可读的编程语言。目标位.NET框架的语言被编译成(C)IL,然后汇编为字节码。(C)IL类似于一个面向对象的汇编语言，并且他是完全基于堆栈的，并且是在虚拟机上（.Net Framework, Mono VM）运行的语言。</p>
<p>IL2CPP(把IL中间语言转换成C++源代码，然后利用标准c++平台编译器产生二进制文件。简单的来说就是将IL转化为CPP文件。)</p>
<p>Fundamentally, it differs from the current implementation in that the IL2CPP compiler converts <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Assembly_(CLI)">assemblies</a> into C++ source code. It then leverages the standard platform C++ compilers to produce native binaries.（这是下面的文章对IL2CPP的部分描述）</p>
<p>这里有一篇Unity3D官方博客的文章，引出了IL2CPP的概念，以及一篇对IL2CPP的介绍。（值得一看）</p>
<p><a target="_blank" rel="noopener" href="https://blog.unity.com/technology/the-future-of-scripting-in-unity"><strong>The future of scripting in Unity</strong></a></p>
<p><a target="_blank" rel="noopener" href="https://blog.unity.com/technology/an-introduction-to-ilcpp-internals"><strong>An introduction to IL2CPP internals</strong></a>  </p>
<p>文中指出IL2CPP由AOT预编译器和虚拟机两部分组成。并且明确指出IL2CPP不会重新构建整个.NET框架和Mono工具链；MonoC#编译器和Mono的类、库，以及现在支持的功能和MonoAOT使用的第三方库都将会和IL2CPP继续使用</p>
<p>下图为IL2CPP的工具链概念图</p>
<p><img src="/2022/03/25/IL2CPP%E5%AD%A6%E4%B9%A0/il2cpp-toolchain-smaller.png" alt="il2cpp-toolchain-smaller"></p>
<p>文中还提到了AOT预编译(<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/AOT_compiler">Ahead of Time</a>)，可以做个了解。主要是对程序在运行前进行优化。</p>
<h2 id="IL2CPP是怎样工作的"><a href="#IL2CPP是怎样工作的" class="headerlink" title="IL2CPP是怎样工作的"></a>IL2CPP是怎样工作的</h2><p><img src="/2022/03/25/IL2CPP%E5%AD%A6%E4%B9%A0/IL2CPP-3.png" alt="IL2CPP-3"></p>
<p>整体流程可以用如上图表示，例子详见上面的第二篇文章</p>
<p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/560/Documentation/Manual/IL2CPP-HowItWorks.html">How IL2CPP works</a></p>
<ol>
<li>Unityj scripting API 代码被编译为常规的.NETDLL程序集</li>
<li>所有的不是脚本的一部分的托管程序集由Unused Bytecode Stripper处理（从动态链接库的DLL中去除一些无用的类和方法），这个过程会显著减小创建游戏的大小。（其上在上面那片文章也有提到）</li>
<li>所有的托管程序集被翻译为标准的C++代码</li>
<li>生成的C++代码和IL2CPP运行时生成的部分代码被本地平台的编译器编译</li>
<li>最后，代码会被连接到可执行文件（取决于你的目标平台）或DLL文件。</li>
</ol>
<p>至于为什么会产生许多无用代码</p>
<p>我们易一段简单的C++代码和IL汇编代码作为示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world: %d\r\n&quot;</span>, a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ldc.i4.1 #将常量1压入栈</span><br><span class="line">stloc.0 #将1从栈中取出，并赋给第一个变量a</span><br><span class="line">ldc.i4.2 </span><br><span class="line">stloc.1</span><br><span class="line">ldstr &quot;Hello World: &#123;0&#125;&quot; #将字符串压入栈</span><br><span class="line">ldloc.0 #将变量a压入栈</span><br><span class="line">ldloc.1</span><br><span class="line">add #a+b</span><br><span class="line">box System.Int32 #将类型装箱，其实这一步是在一定程度上优化程序</span><br><span class="line">call System.Void System.Console::WriteLine(System.String,System.Object) #输出函数调用</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#这块程序集对应上面大括号里的内容</span><br></pre></td></tr></table></figure>

<p>接下来插入一段对应IL2CPP工作的第一部后出现的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// System.Void HelloWorld.Program::Main(System.String[])</span><br><span class="line">IL2CPP_EXTERN_C IL2CPP_METHOD_ATTR void Program_Main_m7A2CC8035362C204637A882EDBDD0999B3D31776 (StringU5BU5D_t933FB07893230EA91C40FF900D5400665E87B14E* ___args0, const RuntimeMethod* method)</span><br><span class="line">&#123;</span><br><span class="line">    static bool s_Il2CppMethodInitialized;</span><br><span class="line">    if (!s_Il2CppMethodInitialized)</span><br><span class="line">    &#123;</span><br><span class="line">        il2cpp_codegen_initialize_method (Program_Main_m7A2CC8035362C204637A882EDBDD0999B3D31776_MetadataUsageId);</span><br><span class="line">        s_Il2CppMethodInitialized = true;</span><br><span class="line">    &#125;</span><br><span class="line">    int32_t V_0 = 0;</span><br><span class="line">    int32_t V_1 = 0;</span><br><span class="line">    &#123;</span><br><span class="line">        V_0 = 2;</span><br><span class="line">        int32_t L_0 = V_0;</span><br><span class="line">        V_1 = ((int32_t)il2cpp_codegen_add((int32_t)1, (int32_t)L_0));</span><br><span class="line">        int32_t L_1 = V_1;</span><br><span class="line">        int32_t L_2 = L_1;</span><br><span class="line">        RuntimeObject * L_3 = Box(Int32_t585191389E07734F19F3156FF88FB3EF4800D102_il2cpp_TypeInfo_var, &amp;L_2);</span><br><span class="line">        IL2CPP_RUNTIME_CLASS_INIT(Console_t5C8E87BA271B0DECA837A3BF9093AC3560DB3D5D_il2cpp_TypeInfo_var);</span><br><span class="line">        Console_WriteLine_m22F0C6199F705AB340B551EA46D3DB63EE4C6C56(_stringLiteral331919585E3D6FC59F6389F88AE91D15E4D22DD4, L_3, /*hidden argument*/NULL);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到代码非常复杂。</p>
<p>如此复杂的原因在于IL2CPP对IL字节码线性扫描，并转换为与C++代码等效的非基于堆栈的代码。所以才会产生如此多的多余的变量和赋值操作。</p>
<p>再接下来，是IL2CPP版本的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">; void __fastcall Program_Main_m2325437134(Il2CppObject *__this, StringU5BU5D_t1642385972 *___args0, MethodInfo *method)</span><br><span class="line">Program_Main_m2325437134 proc near</span><br><span class="line">push    rbx</span><br><span class="line">sub     rsp, 20h</span><br><span class="line">cmp     cs:s_Il2CppMethodInitialized_8016, 0</span><br><span class="line">jnz     short loc_14038BFF1</span><br><span class="line">mov     ecx, cs:?Program_Main_m2325437134_MetadataUsageId@@3IB</span><br><span class="line">call    ?InitializeMethodMetadata@MetadataCache@vm@il2cpp@@SAXI@Z</span><br><span class="line">mov     cs:s_Il2CppMethodInitialized_8016, 1</span><br><span class="line">loc_14038BFF1:</span><br><span class="line">mov     rcx, cs:?Int32_t2071877448_il2cpp_TypeInfo_var@@3PEAUIl2CppClass@@EA</span><br><span class="line">lea     rdx, [rsp+48h]</span><br><span class="line">mov     dword ptr [rsp+48h], 3</span><br><span class="line">call    ?Box@Object@vm@il2cpp@@SAPEAUIl2CppObject@@PEAUIl2CppClass@@PEAX@Z</span><br><span class="line">mov     rcx, cs:?Console_t2311202731_il2cpp_TypeInfo_var@@3PEAUIl2CppClass@@EA</span><br><span class="line">mov     rbx, rax</span><br><span class="line">test    byte ptr [rcx+10Ah], 1</span><br><span class="line">jz      short loc_14038C02B</span><br><span class="line">cmp     dword ptr [rcx+0BCh], 0</span><br><span class="line">jnz     short loc_14038C02B</span><br><span class="line">call    ?ClassInit@Runtime@vm@il2cpp@@SAXPEAUIl2CppClass@@@Z</span><br><span class="line">loc_14038C02B:</span><br><span class="line">mov     rdx, cs:?_stringLiteral3443654334@@3PEAUString_t2029220233@@EA</span><br><span class="line">xor     r9d, r9d</span><br><span class="line">mov     r8, rbx</span><br><span class="line">xor     ecx, ecx</span><br><span class="line">call    Console_WriteLine_m3776981455</span><br><span class="line">add     rsp, 20h</span><br><span class="line">pop     rbx</span><br><span class="line">retn</span><br><span class="line">Program_Main_m2325437134 endp</span><br></pre></td></tr></table></figure>



<p>可以看到有很多刚开始没有的符号，这时候就需要用一些工具去除这些多余的符号了，完全去除，就可以开始分析代码了。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>（本文是在做一个Unitylab的时候当作前置知识学习的一篇简短的笔记，原本想着和Unitylab实验的思路一起发出来，还是提前发了。）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2298233831.github.io/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yu4n">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Blog of Yu4n">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">angrLAB笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-08 10:14:02" itemprop="dateCreated datePublished" datetime="2022-03-08T10:14:02+08:00">2022-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 17:49:26" itemprop="dateModified" datetime="2022-03-25T17:49:26+08:00">2022-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>实验开始前还得先把文件编译一下</p>
<p>在相应目录下，使用如下命令，如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python generate.py 1234 00_angr_find</span><br></pre></td></tr></table></figure>

<p>贴一个angr中文文档<a target="_blank" rel="noopener" href="https://github.com/anhkgg/angr-doc-zh_CN">angr</a> （非官方）</p>
<p><a target="_blank" rel="noopener" href="https://docs.angr.io/core-concepts/solver">angr-官方</a>,英文的。<a target="_blank" rel="noopener" href="https://angr.io/api-doc/">angr-api</a>,英语苦手泪目。</p>
<p>（本题中，有些导入的库不一定那个用得到，但是题目数量多，懒得增删改，就一次性导入了…）</p>
<h2 id="00-angr-find"><a href="#00-angr-find" class="headerlink" title="00_angr_find"></a>00_angr_find</h2><p>先上伪代码</p>
<p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220308172612146.png" alt="image-20220308172612146"></p>
<p>当然，其实这整个实验，汇编语言是很重要的，伪代码是为了帮助理清程序逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.text:0804864E                 push    offset s2       ; &quot;FPQPMQXT&quot;</span><br><span class="line">.text:08048653                 lea     eax, [ebp+s1]</span><br><span class="line">.text:08048656                 push    eax             ; s1</span><br><span class="line">.text:08048657                 call    _strcmp</span><br><span class="line">.text:0804865C                 add     esp, 10h</span><br><span class="line">.text:0804865F                 test    eax, eax</span><br><span class="line">.text:08048661                 jz      short loc_8048675</span><br><span class="line">.text:08048663                 sub     esp, 0Ch</span><br><span class="line">.text:08048666                 push    offset s        ; &quot;Try again.&quot;</span><br><span class="line">.text:0804866B                 call    _puts</span><br><span class="line">.text:08048670                 add     esp, 10h</span><br><span class="line">.text:08048673                 jmp     short loc_8048685</span><br><span class="line">.text:08048675 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:08048675</span><br><span class="line">.text:08048675 loc_8048675:                            ; CODE XREF: main+9A↑j</span><br><span class="line">.text:08048675                 sub     esp, 0Ch</span><br><span class="line">.text:08048678                 push    offset aGoodJob ; &quot;Good Job.&quot;</span><br><span class="line">.text:0804867D                 call    _puts</span><br><span class="line">.text:08048682                 add     esp, 10h</span><br><span class="line">.text:08048685</span><br><span class="line">.text:08048685 loc_8048685:</span><br></pre></td></tr></table></figure>

<p>（这题可以直接逆来着）</p>
<p>发现程序中正确结果的走向，有good job语句，利用angr的explore，让angr找到相对应路径，执行即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    path_to_binary = <span class="string">&quot;E:\\LAB\\angr\\angr\program\\00_angr_find&quot;</span><span class="comment">#打开二进制文件</span></span><br><span class="line">    project = angr.Project(path_to_binary, auto_load_libs=<span class="literal">False</span>)<span class="comment">#创建对象</span></span><br><span class="line">    initial_state = project.factory.entry_state()<span class="comment">#state初始化</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    print_good_address = <span class="number">0x8048678</span>  </span><br><span class="line">    simulation.explore(find=print_good_address)<span class="comment">#寻找地址对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        solution = solution_state.posix.dumps(sys.stdin.fileno())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;THE Answer is: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(solution))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="01-angr-avoid"><a href="#01-angr-avoid" class="headerlink" title="01_angr_avoid"></a>01_angr_avoid</h2><p>这题因为太大反汇编不了，所以还是得看汇编。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.text:0804890F                 jz      short loc_804892E</span><br><span class="line">.text:08048911                 call    avoid_me</span><br><span class="line">.text:08048916                 sub     esp, 8</span><br><span class="line">.text:08048919                 lea     eax, [ebp+var_20]</span><br><span class="line">.text:0804891C                 push    eax</span><br><span class="line">.text:0804891D                 lea     eax, [ebp+var_34]</span><br><span class="line">.text:08048920                 push    eax</span><br><span class="line">.text:08048921                 call    maybe_good</span><br><span class="line">.text:08048926                 add     esp, 10h</span><br><span class="line">.text:08048929                 jmp     loc_80D456F</span><br><span class="line">.text:0804892E ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0804892E</span><br><span class="line">.text:0804892E loc_804892E:                            ; CODE XREF: main+30D↑j</span><br><span class="line">.text:0804892E                 sub     esp, 8</span><br><span class="line">.text:08048931                 lea     eax, [ebp+var_20]</span><br><span class="line">.text:08048934                 push    eax</span><br><span class="line">.text:08048935                 lea     eax, [ebp+var_34]</span><br><span class="line">.text:08048938                 push    eax</span><br><span class="line">.text:08048939                 call    maybe_good</span><br><span class="line">.text:0804893E                 add     esp, 10h</span><br><span class="line">.text:08048941                 jmp     loc_80D456F</span><br><span class="line">.text:08048946 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:08048946</span><br><span class="line">.text:08048946 loc_8048946:                            ; CODE XREF: main+2E5↑j</span><br><span class="line">.text:08048946                 call    avoid_me</span><br><span class="line"></span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">text:080485B5                 public maybe_good</span><br><span class="line">.text:080485B5 maybe_good      proc near               ; CODE XREF: main+31F↓p</span><br><span class="line">.text:080485B5                                         ; main+337↓p ...</span><br><span class="line">.text:080485B5</span><br><span class="line">.text:080485B5 arg_0           = dword ptr  8</span><br><span class="line">.text:080485B5 arg_4           = dword ptr  0Ch</span><br><span class="line">.text:080485B5</span><br><span class="line">.text:080485B5 ; __unwind &#123;</span><br><span class="line">.text:080485B5                 push    ebp</span><br><span class="line">.text:080485B6                 mov     ebp, esp</span><br><span class="line">.text:080485B8                 sub     esp, 8</span><br><span class="line">.text:080485BB                 movzx   eax, should_succeed</span><br><span class="line">.text:080485C2                 test    al, al</span><br><span class="line">.text:080485C4                 jz      short loc_80485EF</span><br><span class="line">.text:080485C6                 sub     esp, 4</span><br><span class="line">.text:080485C9                 push    8</span><br><span class="line">.text:080485CB                 push    [ebp+arg_4]</span><br><span class="line">.text:080485CE                 push    [ebp+arg_0]</span><br><span class="line">.text:080485D1                 call    _strncmp</span><br><span class="line">.text:080485D6                 add     esp, 10h</span><br><span class="line">.text:080485D9                 test    eax, eax</span><br><span class="line">.text:080485DB                 jnz     short loc_80485EF</span><br><span class="line">.text:080485DD                 sub     esp, 0Ch</span><br><span class="line">.text:080485E0                 push    offset aGoodJob ; &quot;Good Job.&quot;</span><br><span class="line">.text:080485E5                 call    _puts</span><br><span class="line">.text:080485EA                 add     esp, 10h</span><br><span class="line">.text:080485ED                 jmp     short loc_80485FF</span><br><span class="line">.text:080485EF ; ---------------------------------------------------------------------------</span><br><span class="line">.text:080485EF</span><br><span class="line">.text:080485EF loc_80485EF:                            ; CODE XREF: maybe_good+F↑j</span><br><span class="line">.text:080485EF                                         ; maybe_good+26↑j</span><br><span class="line">.text:080485EF                 sub     esp, 0Ch</span><br><span class="line">.text:080485F2                 push    offset aTryAgain ; &quot;Try again.&quot;</span><br><span class="line">.text:080485F7                 call    _puts</span><br><span class="line">.text:080485FC                 add     esp, 10h</span><br><span class="line">.text:080485FF</span><br><span class="line">.text:080485FF loc_80485FF:                            ; CODE XREF: maybe_good+38↑j</span><br><span class="line">.text:080485FF                 nop</span><br><span class="line">.text:08048600                 leave</span><br><span class="line">.text:08048601                 retn</span><br><span class="line">.text:08048601 ; &#125; // starts at 80485B5</span><br><span class="line">.text:08048601 maybe_good      endp</span><br><span class="line">.text:08048601</span><br></pre></td></tr></table></figure>

<p>有俩个函数，avoid me和maybegood。字面意思，正确寻址应该在后者里。</p>
<p>查找到goodjob地址为0x080485E0</p>
<p>要避开的tryagain在0x080485F2</p>
<p>（其实这题就把上一题的脚本拿来改个地址也可以得出答案，不过会慢很多，因为不会避开avoidme函数）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    path_to_binary = <span class="string">&quot;E:\\LAB\\angr\\angr\program\\01_angr_avoid&quot;</span></span><br><span class="line">    project = angr.Project(path_to_binary, auto_load_libs=<span class="literal">False</span>)</span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    avoid_me_address =   <span class="number">0x080485A8</span><span class="comment">#avoidme函数首地址，不推介用tryagain来避开，应为没有避开avoidme函数，时间要很久。</span></span><br><span class="line">    maybe_good_address = <span class="number">0x080485E0</span></span><br><span class="line"></span><br><span class="line">    simulation.explore(find=maybe_good_address, avoid=avoid_me_address)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        solution = solution_state.posix.dumps(sys.stdin.fileno())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ANSWER is: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(solution))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个脚本相比于上一道题，在于explore中多了一个avoid&#x3D;要排除执行的路径。</p>
<h2 id="02-angr-find-condition"><a href="#02-angr-find-condition" class="headerlink" title="02_angr_find_condition"></a>02_angr_find_condition</h2><p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220308190311979.png" alt="image-20220308190311979"></p>
<p>首先乍一看，多个goodjob，这题肯定就不能直接寻址goodjob了，不唯一。</p>
<p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220308190505546.png" alt="image-20220308190505546"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">.text:0804876B loc_804876B:                            ; CODE XREF: main+112↑j</span><br><span class="line">.text:0804876B                 cmp     [ebp+var_38], 0DEADBEEFh</span><br><span class="line">.text:08048772                 jz      short loc_80487B5</span><br><span class="line">.text:08048774                 sub     esp, 8</span><br><span class="line">.text:08048777                 lea     eax, [ebp+s2]</span><br><span class="line">.text:0804877A                 push    eax             ; s2</span><br><span class="line">.text:0804877B                 lea     eax, [ebp+s1]</span><br><span class="line">.text:0804877E                 push    eax             ; s1</span><br><span class="line">.text:0804877F                 call    _strcmp</span><br><span class="line">.text:08048784                 add     esp, 10h</span><br><span class="line">.text:08048787                 test    eax, eax</span><br><span class="line">.text:08048789                 jz      short loc_80487A0</span><br><span class="line">.text:0804878B                 sub     esp, 0Ch</span><br><span class="line">.text:0804878E                 push    offset s        ; &quot;Try again.&quot;</span><br><span class="line">.text:08048793                 call    _puts</span><br><span class="line">.text:08048798                 add     esp, 10h</span><br><span class="line">.text:0804879B                 jmp     loc_804D267</span><br><span class="line">.text:080487A0 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:080487A0</span><br><span class="line">.text:080487A0 loc_80487A0:                            ; CODE XREF: main+1C1↑j</span><br><span class="line">.text:080487A0                 sub     esp, 0Ch</span><br><span class="line">.text:080487A3                 push    offset aGoodJob ; &quot;Good Job.&quot;</span><br><span class="line">.text:080487A8                 call    _puts</span><br><span class="line">.text:080487AD                 add     esp, 10h</span><br><span class="line">.text:080487B0                 jmp     loc_804D267</span><br><span class="line">.text:080487B5 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:080487B5</span><br><span class="line">.text:080487B5 loc_80487B5:                            ; CODE XREF: main+1AA↑j</span><br><span class="line">.text:080487B5                 sub     esp, 8</span><br><span class="line">.text:080487B8                 lea     eax, [ebp+s2]</span><br><span class="line">.text:080487BB                 push    eax             ; s2</span><br><span class="line">.text:080487BC                 lea     eax, [ebp+s1]</span><br><span class="line">.text:080487BF                 push    eax             ; s1</span><br><span class="line">.text:080487C0                 call    _strcmp</span><br><span class="line">.text:080487C5                 add     esp, 10h</span><br><span class="line">.text:080487C8                 test    eax, eax</span><br><span class="line">.text:080487CA                 jz      short loc_80487E1</span><br><span class="line">.text:080487CC                 sub     esp, 0Ch</span><br><span class="line">.text:080487CF                 push    offset s        ; &quot;Try again.&quot;</span><br><span class="line">.text:080487D4                 call    _puts</span><br><span class="line">.text:080487D9                 add     esp, 10h</span><br><span class="line">.text:080487DC                 jmp     loc_804D267</span><br><span class="line">.text:080487E1 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:080487E1</span><br><span class="line">.text:080487E1 loc_80487E1:                            ; CODE XREF: main+202↑j</span><br><span class="line">.text:080487E1                 sub     esp, 0Ch</span><br><span class="line">.text:080487E4                 push    offset aGoodJob ; &quot;Good Job.&quot;</span><br><span class="line">.text:080487E9                 call    _puts</span><br></pre></td></tr></table></figure>

<p>当然，这题想要直接逆也是可以的，不过我们还是用angr</p>
<p>首先是思路：够狠上面一样题的是，还是应该回避tryagain一类的失败路径，然后再设置两个回调函数，当返回tryagain时，回避路径，反之则不回避。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    path_to_binary = <span class="string">&quot;E:\\LAB\\angr\\angr\program\\02_angr_find_condition&quot;</span></span><br><span class="line">    project = angr.Project(path_to_binary, auto_load_libs=<span class="literal">False</span>)</span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())<span class="comment">#获取模拟执行的控制台输出</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output:<span class="comment">#根据模拟控制台得输出结果来判断，下面同理。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span><span class="comment">#发现路径</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span><span class="comment">#忽略路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">should_abort</span>(<span class="params">state</span>):</span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span>  stdout_output:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        solution = solution_state.posix.dumps(sys.stdin.fileno())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The ANSWER is: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(solution))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>



<h2 id="03-angr-symbolic-registers"><a href="#03-angr-symbolic-registers" class="headerlink" title="03_angr_symbolic_registers"></a>03_angr_symbolic_registers</h2><p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220308211050475.png" alt="image-20220308211050475"></p>
<p>上面是伪代码。</p>
<p>主函数汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">.text:080488E8 main            proc near               ; DATA XREF: _start+17↑o</span><br><span class="line">.text:080488E8</span><br><span class="line">.text:080488E8 var_14          = dword ptr -14h</span><br><span class="line">.text:080488E8 var_10          = dword ptr -10h</span><br><span class="line">.text:080488E8 var_C           = dword ptr -0Ch</span><br><span class="line">.text:080488E8 var_4           = dword ptr -4</span><br><span class="line">.text:080488E8 argc            = dword ptr  8</span><br><span class="line">.text:080488E8 argv            = dword ptr  0Ch</span><br><span class="line">.text:080488E8 envp            = dword ptr  10h</span><br><span class="line">.text:080488E8</span><br><span class="line">.text:080488E8 ; __unwind &#123;</span><br><span class="line">.text:080488E8                 lea     ecx, [esp+4]</span><br><span class="line">.text:080488EC                 and     esp, 0FFFFFFF0h</span><br><span class="line">.text:080488EF                 push    dword ptr [ecx-4]</span><br><span class="line">.text:080488F2                 push    ebp</span><br><span class="line">.text:080488F3                 mov     ebp, esp</span><br><span class="line">.text:080488F5                 push    ecx</span><br><span class="line">.text:080488F6                 sub     esp, 14h</span><br><span class="line">.text:080488F9                 sub     esp, 0Ch</span><br><span class="line">.text:080488FC                 push    offset aEnterThePasswo ; &quot;Enter the password: &quot;</span><br><span class="line">.text:08048901                 call    _printf</span><br><span class="line">.text:08048906                 add     esp, 10h</span><br><span class="line">.text:08048909                 call    get_user_input</span><br><span class="line">.text:0804890E                 mov     [ebp+var_14], eax</span><br><span class="line">.text:08048911                 mov     [ebp+var_10], ebx</span><br><span class="line">.text:08048914                 mov     [ebp+var_C], edx</span><br><span class="line">.text:08048917                 sub     esp, 0Ch</span><br><span class="line">.text:0804891A                 push    [ebp+var_14]</span><br><span class="line">.text:0804891D                 call    complex_function_1</span><br><span class="line">.text:08048922                 add     esp, 10h</span><br><span class="line">.text:08048925                 mov     ecx, eax</span><br><span class="line">.text:08048927                 mov     [ebp+var_14], ecx</span><br><span class="line">.text:0804892A                 sub     esp, 0Ch</span><br><span class="line">.text:0804892D                 push    [ebp+var_10]</span><br><span class="line">.text:08048930                 call    complex_function_2</span><br><span class="line">.text:08048935                 add     esp, 10h</span><br><span class="line">.text:08048938                 mov     ecx, eax</span><br><span class="line">.text:0804893A                 mov     [ebp+var_10], ecx</span><br><span class="line">.text:0804893D                 sub     esp, 0Ch</span><br><span class="line">.text:08048940                 push    [ebp+var_C]</span><br><span class="line">.text:08048943                 call    complex_function_3</span><br><span class="line">.text:08048948                 add     esp, 10h</span><br><span class="line">.text:0804894B                 mov     ecx, eax</span><br><span class="line">.text:0804894D                 mov     [ebp+var_C], ecx</span><br><span class="line">.text:08048950                 cmp     [ebp+var_14], 0</span><br><span class="line">.text:08048954                 jnz     short loc_8048962</span><br><span class="line">.text:08048956                 cmp     [ebp+var_10], 0</span><br><span class="line">.text:0804895A                 jnz     short loc_8048962</span><br><span class="line">.text:0804895C                 cmp     [ebp+var_C], 0</span><br><span class="line">.text:08048960                 jz      short loc_8048974</span><br></pre></td></tr></table></figure>

<p>可以看到，四个函数调用。第一个就是让我们输入三个数；eax，ebx，edx分别存放输入数据，也是接下来三个函数的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">.text:0804889A get_user_input  proc near               ; CODE XREF: main+21↓p</span><br><span class="line">.text:0804889A</span><br><span class="line">.text:0804889A var_18          = dword ptr -18h</span><br><span class="line">.text:0804889A var_14          = dword ptr -14h</span><br><span class="line">.text:0804889A var_10          = dword ptr -10h</span><br><span class="line">.text:0804889A var_C           = dword ptr -0Ch</span><br><span class="line">.text:0804889A</span><br><span class="line">.text:0804889A ; __unwind &#123;</span><br><span class="line">.text:0804889A                 push    ebp</span><br><span class="line">.text:0804889B                 mov     ebp, esp</span><br><span class="line">.text:0804889D                 sub     esp, 18h</span><br><span class="line">.text:080488A0                 mov     ecx, large gs:14h</span><br><span class="line">.text:080488A7                 mov     [ebp+var_C], ecx</span><br><span class="line">.text:080488AA                 xor     ecx, ecx</span><br><span class="line">.text:080488AC                 lea     ecx, [ebp+var_10]</span><br><span class="line">.text:080488AF                 push    ecx</span><br><span class="line">.text:080488B0                 lea     ecx, [ebp+var_14]</span><br><span class="line">.text:080488B3                 push    ecx</span><br><span class="line">.text:080488B4                 lea     ecx, [ebp+var_18]</span><br><span class="line">.text:080488B7                 push    ecx</span><br><span class="line">.text:080488B8                 push    offset aXXX     ; &quot;%x %x %x&quot;</span><br><span class="line">.text:080488BD                 call    ___isoc99_scanf</span><br><span class="line">.text:080488C2                 add     esp, 10h</span><br><span class="line">.text:080488C5                 mov     ecx, [ebp+var_18]</span><br><span class="line">.text:080488C8                 mov     eax, ecx</span><br><span class="line">.text:080488CA                 mov     ecx, [ebp+var_14]</span><br><span class="line">.text:080488CD                 mov     ebx, ecx</span><br><span class="line">.text:080488CF                 mov     ecx, [ebp+var_10]</span><br><span class="line">.text:080488D2                 mov     edx, ecx</span><br><span class="line">.text:080488D4                 nop</span><br><span class="line">.text:080488D5                 mov     ecx, [ebp+var_C]</span><br><span class="line">.text:080488D8                 xor     ecx, large gs:14h</span><br><span class="line">.text:080488DF                 jz      short locret_80488E6</span><br><span class="line">.text:080488E1                 call    ___stack_chk_fail</span><br><span class="line">.text:080488E6 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:080488E6</span><br><span class="line">.text:080488E6 locret_80488E6:                         ; CODE XREF: get_user_input+45↑j</span><br><span class="line">.text:080488E6                 leave</span><br><span class="line">.text:080488E7                 retn</span><br><span class="line">.text:080488E7 ; &#125; // starts at 804889A</span><br><span class="line">.text:080488E7 get_user_input  endp</span><br></pre></td></tr></table></figure>

<p>我们看接下来三个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">.text:08048509 complex_function_1 proc near            ; CODE XREF: main+35↓p</span><br><span class="line">.text:08048509</span><br><span class="line">.text:08048509 arg_0           = dword ptr  8</span><br><span class="line">.text:08048509</span><br><span class="line">.text:08048509 ; __unwind &#123;</span><br><span class="line">.text:08048509                 push    ebp</span><br><span class="line">.text:0804850A                 mov     ebp, esp</span><br><span class="line">.text:0804850C                 xor     [ebp+arg_0], 0A78D4A5Fh</span><br><span class="line">.text:08048513                 add     [ebp+arg_0], 3EC98793h</span><br><span class="line">.text:0804851A                 xor     [ebp+arg_0], 51FCDF96h</span><br><span class="line">.text:08048521                 add     [ebp+arg_0], 546F1B35h</span><br><span class="line">.text:08048528                 add     [ebp+arg_0], 7CD06332h</span><br><span class="line">.text:0804852F                 add     [ebp+arg_0], 3BEEDF0Bh</span><br><span class="line">.text:08048536                 add     [ebp+arg_0], 5824146Ch</span><br><span class="line">.text:0804853D                 add     [ebp+arg_0], 15CBC4FFh</span><br><span class="line">.text:08048544                 mov     ecx, [ebp+arg_0]</span><br><span class="line">.text:08048547                 sub     ecx, 46C32D9h</span><br><span class="line">.text:0804854D                 mov     [ebp+arg_0], ecx</span><br><span class="line">.text:08048550                 xor     [ebp+arg_0], 9B99C626h</span><br><span class="line">.text:08048557                 add     [ebp+arg_0], 6590A23Dh</span><br><span class="line">.text:0804855E                 xor     [ebp+arg_0], 0D16C9C3Ch</span><br><span class="line">.text:08048565                 xor     [ebp+arg_0], 0D73D3031h</span><br><span class="line">.text:0804856C                 xor     [ebp+arg_0], 37EB59D3h</span><br><span class="line">.text:08048573                 mov     ecx, [ebp+arg_0]</span><br><span class="line">.text:08048576                 sub     ecx, 5DDF68E6h</span><br><span class="line">.text:0804857C                 mov     [ebp+arg_0], ecx</span><br><span class="line">.text:0804857F                 mov     ecx, [ebp+arg_0]</span><br><span class="line">.text:08048582                 sub     ecx, 64F2CB17h</span><br><span class="line">.text:08048588                 mov     [ebp+arg_0], ecx</span><br><span class="line">.text:0804858B                 xor     [ebp+arg_0], 0F1C347B6h</span><br><span class="line">.text:08048592                 xor     [ebp+arg_0], 0BB664966h</span><br><span class="line">.text:08048599                 xor     [ebp+arg_0], 0DCD816D2h</span><br><span class="line">.text:080485A0                 xor     [ebp+arg_0], 0A523DD67h</span><br><span class="line">.text:080485A7                 add     [ebp+arg_0], 2C64C6B3h</span><br><span class="line">.text:080485AE                 mov     ecx, [ebp+arg_0]</span><br><span class="line">.text:080485B1                 sub     ecx, 632C11C3h</span><br><span class="line">.text:080485B7                 mov     [ebp+arg_0], ecx</span><br><span class="line">.text:080485BA                 add     [ebp+arg_0], 220BCB4Ch</span><br><span class="line">.text:080485C1                 xor     [ebp+arg_0], 0C13B368Ah</span><br><span class="line">.text:080485C8                 xor     [ebp+arg_0], 7323522h</span><br><span class="line">.text:080485CF                 mov     ecx, [ebp+arg_0]</span><br><span class="line">.text:080485D2                 sub     ecx, 7FA5CE75h</span><br><span class="line">.text:080485D8                 mov     [ebp+arg_0], ecx</span><br><span class="line">.text:080485DB                 add     [ebp+arg_0], 2BA5F91Ah</span><br><span class="line">.text:080485E2                 xor     [ebp+arg_0], 0CEF3925Eh</span><br><span class="line">.text:080485E9                 xor     [ebp+arg_0], 879B8252h</span><br><span class="line">.text:080485F0                 add     [ebp+arg_0], 6D4F923Bh</span><br><span class="line">.text:080485F7                 mov     ecx, [ebp+arg_0]</span><br><span class="line">.text:080485FA                 sub     ecx, 491AF770h</span><br><span class="line">.text:08048600                 mov     [ebp+arg_0], ecx</span><br><span class="line">.text:08048603                 xor     [ebp+arg_0], 96C75B6h</span><br><span class="line">.text:0804860A                 xor     [ebp+arg_0], 51EC989Bh</span><br><span class="line">.text:08048611                 xor     [ebp+arg_0], 0DE67C3E3h</span><br><span class="line">.text:08048618                 add     [ebp+arg_0], 2C688544h</span><br><span class="line">.text:0804861F                 xor     [ebp+arg_0], 6A479F09h</span><br><span class="line">.text:08048626                 xor     [ebp+arg_0], 0D8B0FF0Dh</span><br><span class="line">.text:0804862D                 xor     [ebp+arg_0], 37172519h</span><br><span class="line">.text:08048634                 mov     ecx, [ebp+arg_0]</span><br><span class="line">.text:08048637                 mov     eax, ecx</span><br><span class="line">.text:08048639                 pop     ebp</span><br><span class="line">.text:0804863A                 retn</span><br><span class="line">.text:0804863A ; &#125; // starts at 8048509</span><br><span class="line">.text:0804863A complex_function_1 endp</span><br></pre></td></tr></table></figure>

<p>逻辑简单，就是异或。</p>
<p>来说整体思路：</p>
<p>首先是三个参数，要异或过后符合要求，输出goodjob。由于这题没有指出最后要比较的三个数的具体的值，所以我们不能套用前面那的方法。此处应该控制输入的三个值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    path_to_binary = <span class="string">&quot;E:\\LAB\\angr\\angr\program\\03_angr_symbolic_registers&quot;</span> </span><br><span class="line">    project = angr.Project(path_to_binary)</span><br><span class="line">    start_addr = <span class="number">0x0804890E</span></span><br><span class="line">    initial_state = project.factory.blank_state(addr=start_addr)</span><br><span class="line">	</span><br><span class="line">    passwd_size_in_bits = <span class="number">32</span></span><br><span class="line">    passwd0 = claripy.BVS(<span class="string">&#x27;passwd0&#x27;</span>, passwd_size_in_bits)<span class="comment">#开始初始化符号位向量</span></span><br><span class="line">    passwd1 = claripy.BVS(<span class="string">&#x27;passwd1&#x27;</span>, passwd_size_in_bits)</span><br><span class="line">    passwd2 = claripy.BVS(<span class="string">&#x27;passwd2&#x27;</span>, passwd_size_in_bits)</span><br><span class="line"></span><br><span class="line">    initial_state.regs.eax = passwd0<span class="comment">#更新寄存器内容</span></span><br><span class="line">    initial_state.regs.ebx = passwd1</span><br><span class="line">    initial_state.regs.edx = passwd2</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(initial_state) </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">should_abort</span>(<span class="params">state</span>):</span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span>  stdout_output:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> simulation.found:</span><br><span class="line">            solution_state = i</span><br><span class="line">            solution0 = <span class="built_in">format</span>(solution_state.solver.<span class="built_in">eval</span>(passwd0), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">            solution1 = <span class="built_in">format</span>(solution_state.solver.<span class="built_in">eval</span>(passwd1), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">            solution2 = <span class="built_in">format</span>(solution_state.solver.<span class="built_in">eval</span>(passwd2), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">            solution = solution0 + <span class="string">&quot; &quot;</span> + solution1 + <span class="string">&quot; &quot;</span> + solution2</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The ANSWER is: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(solution))</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="04-angr-symbolic-stack"><a href="#04-angr-symbolic-stack" class="headerlink" title="04_angr_symbolic_stack"></a>04_angr_symbolic_stack</h2><p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220308215004547.png" alt="image-20220308215004547"></p>
<p>可以明确，关键在handle_user函数里面</p>
<p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220308215133653.png" alt="image-20220308215133653"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">handle_user     proc near               ; CODE XREF: main+21↓p</span><br><span class="line">.text:08048679</span><br><span class="line">.text:08048679 var_10          = dword ptr -10h</span><br><span class="line">.text:08048679 var_C           = dword ptr -0Ch</span><br><span class="line">.text:08048679</span><br><span class="line">.text:08048679 ; __unwind &#123;</span><br><span class="line">.text:08048679                 push    ebp</span><br><span class="line">.text:0804867A                 mov     ebp, esp</span><br><span class="line">.text:0804867C                 sub     esp, 18h</span><br><span class="line">.text:0804867F                 sub     esp, 4</span><br><span class="line">.text:08048682                 lea     eax, [ebp+var_10]</span><br><span class="line">.text:08048685                 push    eax</span><br><span class="line">.text:08048686                 lea     eax, [ebp+var_C]</span><br><span class="line">.text:08048689                 push    eax</span><br><span class="line">.text:0804868A                 push    offset aUU      ; &quot;%u %u&quot;</span><br><span class="line">.text:0804868F                 call    ___isoc99_scanf</span><br><span class="line">.text:08048694                 add     esp, 10h</span><br><span class="line">.text:08048697                 mov     eax, [ebp+var_C]</span><br><span class="line">.text:0804869A                 sub     esp, 0Ch</span><br><span class="line">.text:0804869D                 push    eax</span><br><span class="line">.text:0804869E                 call    complex_function0</span><br><span class="line">.text:080486A3                 add     esp, 10h</span><br><span class="line">.text:080486A6                 mov     [ebp+var_C], eax</span><br><span class="line">.text:080486A9                 mov     eax, [ebp+var_10]</span><br><span class="line">.text:080486AC                 sub     esp, 0Ch</span><br><span class="line">.text:080486AF                 push    eax</span><br><span class="line">.text:080486B0                 call    complex_function1</span><br><span class="line">.text:080486B5                 add     esp, 10h</span><br><span class="line">.text:080486B8                 mov     [ebp+var_10], eax</span><br><span class="line">.text:080486BB                 mov     eax, [ebp+var_C]</span><br><span class="line">.text:080486BE                 cmp     eax, 0D3062A4Ch</span><br><span class="line">.text:080486C3                 jnz     short loc_80486CF</span><br><span class="line">.text:080486C5                 mov     eax, [ebp+var_10]</span><br><span class="line">.text:080486C8                 cmp     eax, 694E5BA0h</span><br><span class="line">.text:080486CD                 jz      short loc_80486E1</span><br><span class="line">.text:080486CF</span><br><span class="line">.text:080486CF loc_80486CF:                            ; CODE XREF: handle_user+4A↑j</span><br><span class="line">.text:080486CF                 sub     esp, 0Ch</span><br><span class="line">.text:080486D2                 push    offset s        ; &quot;Try again.&quot;</span><br><span class="line">.text:080486D7                 call    _puts</span><br><span class="line">.text:080486DC                 add     esp, 10h</span><br><span class="line">.text:080486DF                 jmp     short loc_80486F1</span><br><span class="line">.text:080486E1 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:080486E1</span><br><span class="line">.text:080486E1 loc_80486E1:                            ; CODE XREF: handle_user+54↑j</span><br><span class="line">.text:080486E1                 sub     esp, 0Ch</span><br><span class="line">.text:080486E4                 push    offset aGoodJob ; &quot;Good Job.&quot;</span><br><span class="line">.text:080486E9                 call    _puts</span><br><span class="line">.text:080486EE                 add     esp, 10h</span><br><span class="line">.text:080486F1</span><br><span class="line">.text:080486F1 loc_80486F1:                            ; CODE XREF: handle_user+66↑j</span><br><span class="line">.text:080486F1                 nop</span><br><span class="line">.text:080486F2                 leave</span><br><span class="line">.text:080486F3                 retn</span><br><span class="line">.text:080486F3 ; &#125; // starts at 8048679</span><br><span class="line">.text:080486F3 handle_user     endp</span><br></pre></td></tr></table></figure>

<p>我们可以看一下complex_function0的函数汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">.text:080484A9 complex_function0 proc near             ; CODE XREF: handle_user+25↓p</span><br><span class="line">.text:080484A9</span><br><span class="line">.text:080484A9 arg_0           = dword ptr  8</span><br><span class="line">.text:080484A9</span><br><span class="line">.text:080484A9 ; __unwind &#123;</span><br><span class="line">.text:080484A9                 push    ebp</span><br><span class="line">.text:080484AA                 mov     ebp, esp</span><br><span class="line">.text:080484AC                 xor     [ebp+arg_0], 0D53642BEh</span><br><span class="line">.text:080484B3                 xor     [ebp+arg_0], 58FC2926h</span><br><span class="line">.text:080484BA                 xor     [ebp+arg_0], 25596A36h</span><br><span class="line">.text:080484C1                 xor     [ebp+arg_0], 0A7AFAA43h</span><br><span class="line">.text:080484C8                 xor     [ebp+arg_0], 1559CAFEh</span><br><span class="line">.text:080484CF                 xor     [ebp+arg_0], 0D8D89C66h</span><br><span class="line">.text:080484D6                 xor     [ebp+arg_0], 6B8B30B6h</span><br><span class="line">.text:080484DD                 xor     [ebp+arg_0], 0B5E7C180h</span><br><span class="line">.text:080484E4                 xor     [ebp+arg_0], 1FA429F6h</span><br><span class="line">.text:080484EB                 xor     [ebp+arg_0], 21C70AF4h</span><br><span class="line">.text:080484F2                 xor     [ebp+arg_0], 0B7261E1Dh</span><br><span class="line">.text:080484F9                 xor     [ebp+arg_0], 0ADD88AD8h</span><br><span class="line">.text:08048500                 xor     [ebp+arg_0], 3E16A0F2h</span><br><span class="line">.text:08048507                 xor     [ebp+arg_0], 0DF2308FBh</span><br><span class="line">.text:0804850E                 xor     [ebp+arg_0], 2273AAFh</span><br><span class="line">.text:08048515                 xor     [ebp+arg_0], 8E69AC70h</span><br><span class="line">.text:0804851C                 xor     [ebp+arg_0], 0AC8924h</span><br><span class="line">.text:08048523                 xor     [ebp+arg_0], 561B782h</span><br><span class="line">.text:0804852A                 xor     [ebp+arg_0], 5A64A924h</span><br><span class="line">.text:08048531                 xor     [ebp+arg_0], 0B118005Bh</span><br><span class="line">.text:08048538                 xor     [ebp+arg_0], 61461EA2h</span><br><span class="line">.text:0804853F                 xor     [ebp+arg_0], 0E0E04E79h</span><br><span class="line">.text:08048546                 xor     [ebp+arg_0], 0A8DDACAAh</span><br><span class="line">.text:0804854D                 xor     [ebp+arg_0], 82AF667Dh</span><br><span class="line">.text:08048554                 xor     [ebp+arg_0], 0B3CB4464h</span><br><span class="line">.text:0804855B                 xor     [ebp+arg_0], 43B7BB1Ah</span><br><span class="line">.text:08048562                 xor     [ebp+arg_0], 0DF30F25Bh</span><br><span class="line">.text:08048569                 xor     [ebp+arg_0], 4C0F3376h</span><br><span class="line">.text:08048570                 xor     [ebp+arg_0], 0B2E462E5h</span><br><span class="line">.text:08048577                 xor     [ebp+arg_0], 7BF4CFC3h</span><br><span class="line">.text:0804857E                 xor     [ebp+arg_0], 0C2960388h</span><br><span class="line">.text:08048585                 xor     [ebp+arg_0], 27071524h</span><br><span class="line">.text:0804858C                 mov     eax, [ebp+arg_0]</span><br><span class="line">.text:0804858F                 pop     ebp</span><br><span class="line">.text:08048590                 retn</span><br><span class="line">.text:08048590 ; &#125; // starts at 80484A9</span><br><span class="line">.text:08048590 complex_function0 endp</span><br></pre></td></tr></table></figure>

<p>其实可以看出，跟上一题的思路其实相差不大。所以本题，我们也需要控制两个参数。</p>
<p>故，思路如下：</p>
<p>开始地址设置在输入函数之后，传参数给complex之前。通过complex函数内部可以知道，esp寄存器的值给了ebp（两个complex函数都是这样）。然后我们设置两个参数并将其压入栈。之后的操作和上一题大同小异</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">pro =angr.Project(<span class="string">&quot;E:\\LAB\\angr\\angr\program\\04_angr_symbolic_stack&quot;</span>)</span><br><span class="line"></span><br><span class="line">start_addr = <span class="number">0x08048697</span></span><br><span class="line">init_state = pro.factory.blank_state(addr=start_addr)</span><br><span class="line"></span><br><span class="line">init_state.regs.ebp = init_state.regs.esp</span><br><span class="line"></span><br><span class="line">passwd0 = claripy.BVS(<span class="string">&quot;passwd0&quot;</span>, <span class="number">32</span>)</span><br><span class="line">passwd1 = claripy.BVS(<span class="string">&quot;passwd1&quot;</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">init_state.regs.esp -= <span class="number">8</span></span><br><span class="line">init_state.stack_push(passwd0)</span><br><span class="line">init_state.stack_push(passwd1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">simulation = pro.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">success</span>(<span class="params">state</span>):</span><br><span class="line">    output = state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&quot;Good Job.&quot;</span> <span class="keyword">in</span> output</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">abort</span>(<span class="params">state</span>):</span><br><span class="line">    output = state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&quot;Try again.&quot;</span> <span class="keyword">in</span> output</span><br><span class="line"></span><br><span class="line">simulation.explore(find=success, avoid=abort)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    res = simulation.found[<span class="number">0</span>]</span><br><span class="line">    solution0 = res.solver.<span class="built_in">eval</span>(passwd0)</span><br><span class="line">    solution1 = res.solver.<span class="built_in">eval</span>(passwd1)</span><br><span class="line">    </span><br><span class="line">    solution = <span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, [solution0, solution1]))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The Answer is :&#123;&#125;&quot;</span>.<span class="built_in">format</span>(solution))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No Answer!&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="05-angr-symbolic-memory"><a href="#05-angr-symbolic-memory" class="headerlink" title="05_angr_symbolic_memory"></a>05_angr_symbolic_memory</h2><p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220310171010963.png" alt="image-20220310171010963"></p>
<p>还是先贴上伪代码</p>
<p>接着看汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">main            proc near               ; DATA XREF: _start+17↑o</span><br><span class="line">.text:080485A8</span><br><span class="line">.text:080485A8 var_C           = dword ptr -0Ch</span><br><span class="line">.text:080485A8 var_4           = dword ptr -4</span><br><span class="line">.text:080485A8 argc            = dword ptr  8</span><br><span class="line">.text:080485A8 argv            = dword ptr  0Ch</span><br><span class="line">.text:080485A8 envp            = dword ptr  10h</span><br><span class="line">.text:080485A8</span><br><span class="line">.text:080485A8 ; __unwind &#123;</span><br><span class="line">.text:080485A8                 lea     ecx, [esp+4]</span><br><span class="line">.text:080485AC                 and     esp, 0FFFFFFF0h</span><br><span class="line">.text:080485AF                 push    dword ptr [ecx-4]</span><br><span class="line">.text:080485B2                 push    ebp</span><br><span class="line">.text:080485B3                 mov     ebp, esp</span><br><span class="line">.text:080485B5                 push    ecx</span><br><span class="line">.text:080485B6                 sub     esp, 14h</span><br><span class="line">.text:080485B9                 sub     esp, 4</span><br><span class="line">.text:080485BC                 push    21h ; &#x27;!&#x27;       ; n</span><br><span class="line">.text:080485BE                 push    0               ; c</span><br><span class="line">.text:080485C0                 push    offset user_input ; s</span><br><span class="line">.text:080485C5                 call    _memset</span><br><span class="line">.text:080485CA                 add     esp, 10h</span><br><span class="line">.text:080485CD                 sub     esp, 0Ch</span><br><span class="line">.text:080485D0                 push    offset aEnterThePasswo ; &quot;Enter the password: &quot;</span><br><span class="line">.text:080485D5                 call    _printf</span><br><span class="line">.text:080485DA                 add     esp, 10h</span><br><span class="line">.text:080485DD                 sub     esp, 0Ch</span><br><span class="line">.text:080485E0                 push    offset unk_9FD92B8</span><br><span class="line">.text:080485E5                 push    offset unk_9FD92B0</span><br><span class="line">.text:080485EA                 push    offset unk_9FD92A8</span><br><span class="line">.text:080485EF                 push    offset user_input</span><br><span class="line">.text:080485F4                 push    offset a8s8s8s8s ; &quot;%8s %8s %8s %8s&quot;</span><br><span class="line">.text:080485F9                 call    ___isoc99_scanf</span><br><span class="line">.text:080485FE                 add     esp, 20h</span><br><span class="line">.text:08048601                 mov     [ebp+var_C], 0</span><br><span class="line">.text:08048608                 jmp     short loc_8048637</span><br><span class="line">.text:0804860A ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0804860A</span><br><span class="line">.text:0804860A loc_804860A:                            ; CODE XREF: main+93↓j</span><br><span class="line">.text:0804860A                 mov     eax, [ebp+var_C]</span><br><span class="line">.text:0804860D                 add     eax, 9FD92A0h</span><br><span class="line">.text:08048612                 movzx   eax, byte ptr [eax]</span><br><span class="line">.text:08048615                 movsx   eax, al</span><br><span class="line">.text:08048618                 sub     esp, 8</span><br><span class="line">.text:0804861B                 push    [ebp+var_C]</span><br><span class="line">.text:0804861E                 push    eax</span><br><span class="line">.text:0804861F                 call    complex_function</span><br><span class="line">.text:08048624                 add     esp, 10h</span><br><span class="line">.text:08048627                 mov     edx, eax</span><br><span class="line">.text:08048629                 mov     eax, [ebp+var_C]</span><br><span class="line">.text:0804862C                 add     eax, 9FD92A0h</span><br><span class="line">.text:08048631                 mov     [eax], dl</span><br><span class="line">.text:08048633                 add     [ebp+var_C], 1</span><br><span class="line">.text:08048637</span><br><span class="line">.text:08048637 loc_8048637:                            ; CODE XREF: main+60↑j</span><br><span class="line">.text:08048637                 cmp     [ebp+var_C], 1Fh</span><br><span class="line">.text:0804863B                 jle     short loc_804860A</span><br><span class="line">.text:0804863D                 sub     esp, 4</span><br><span class="line">.text:08048640                 push    20h ; &#x27; &#x27;       ; n</span><br><span class="line">.text:08048642                 push    offset s2       ; &quot;THNJXTHBJUCDIMEEMLZNGMHISXAIXDQG&quot;</span><br><span class="line">.text:08048647                 push    offset user_input ; s1</span><br><span class="line">.text:0804864C                 call    _strncmp</span><br><span class="line">.text:08048651                 add     esp, 10h</span><br><span class="line">.text:08048654                 test    eax, eax</span><br><span class="line">.text:08048656                 jz      short loc_804866A</span><br><span class="line">.text:08048658                 sub     esp, 0Ch</span><br><span class="line">.text:0804865B                 push    offset s        ; &quot;Try again.&quot;</span><br><span class="line">.text:08048660                 call    _puts</span><br><span class="line">.text:08048665                 add     esp, 10h</span><br><span class="line">.text:08048668                 jmp     short loc_804867A</span><br><span class="line">.text:0804866A ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0804866A</span><br><span class="line">.text:0804866A loc_804866A:                            ; CODE XREF: main+AE↑j</span><br><span class="line">.text:0804866A                 sub     esp, 0Ch</span><br><span class="line">.text:0804866D                 push    offset aGoodJob ; &quot;Good Job.&quot;</span><br><span class="line">.text:08048672                 call    _puts</span><br><span class="line">.text:08048677                 add     esp, 10h</span><br><span class="line">.text:0804867A</span><br><span class="line">.text:0804867A loc_804867A:                            ; CODE XREF: main+C0↑j</span><br><span class="line">.text:0804867A                 mov     eax, 0</span><br><span class="line">.text:0804867F                 mov     ecx, [ebp+var_4]</span><br><span class="line">.text:08048682                 leave</span><br><span class="line">.text:08048683                 lea     esp, [ecx-4]</span><br><span class="line">.text:08048686                 retn</span><br><span class="line">.text:08048686 ; &#125; // starts at 80485A8</span><br><span class="line">.text:08048686 main            endp</span><br></pre></td></tr></table></figure>

<p>思路跟上一题差不多，函数开始地址还是设在相应的位置0x08048601</p>
<p>然后是初始化符号位向量，且注意四个数据的地址，然后是一如既往的设置成功的路径和避免的路径。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">project =angr.Project(<span class="string">&quot;E:\\LAB\\angr\\angr\program\\05_angr_symbolic_memory&quot;</span>)</span><br><span class="line"></span><br><span class="line">start_address = <span class="number">0x8048601</span></span><br><span class="line">initial_state = project.factory.blank_state(addr=start_address)</span><br><span class="line"></span><br><span class="line">password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">8</span> * <span class="number">8</span>)</span><br><span class="line">password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">8</span> * <span class="number">8</span>)</span><br><span class="line">password2 = claripy.BVS(<span class="string">&#x27;password2&#x27;</span>, <span class="number">8</span> * <span class="number">8</span>)</span><br><span class="line">password3 = claripy.BVS(<span class="string">&#x27;password3&#x27;</span>, <span class="number">8</span> * <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">password0_address = <span class="number">0x9FD92A0</span></span><br><span class="line">initial_state.memory.store(password0_address, password0)<span class="comment">#初始化地址中的数据</span></span><br><span class="line">password1_address = <span class="number">0x9FD92A8</span></span><br><span class="line">initial_state.memory.store(password1_address, password1)</span><br><span class="line">password2_address = <span class="number">0x9FD92B0</span></span><br><span class="line">initial_state.memory.store(password2_address, password2)</span><br><span class="line">password3_address = <span class="number">0x9FD92B8</span></span><br><span class="line">initial_state.memory.store(password3_address, password3)</span><br><span class="line"></span><br><span class="line">simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Good Job&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">should_abort</span>(<span class="params">state</span>):</span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Try again&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line">simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    solution0 = solution_state.se.<span class="built_in">eval</span>(password0)</span><br><span class="line">    solution1 = solution_state.se.<span class="built_in">eval</span>(password1)</span><br><span class="line">    solution2 = solution_state.se.<span class="built_in">eval</span>(password2)</span><br><span class="line">    solution3 = solution_state.se.<span class="built_in">eval</span>(password3)</span><br><span class="line">    solution = <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="string">&#x27;&#123;:x&#125;&#x27;</span>.<span class="built_in">format</span>, [ solution0, solution1,solution2,solution3 ]))</span><br><span class="line">    </span><br><span class="line">    solution = <span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, [solution0, solution1]))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The Answer is :&#123;&#125;&quot;</span>.<span class="built_in">format</span>(solution))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No Answer!&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="06-angr-symbolic-dynamic-memory"><a href="#06-angr-symbolic-dynamic-memory" class="headerlink" title="06_angr_symbolic_dynamic_memory"></a>06_angr_symbolic_dynamic_memory</h2><p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220312101104842.png" alt="image-20220312101104842"></p>
<p>伪代码如上。</p>
<p>看一下程序逻辑，输入两个数据，经过处理，比较，相等则通过。要注意buffer两个数据是存放在堆区的。、</p>
<p>所以在</p>
<p>main函数部分汇编代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">.text:08048691                 call    ___isoc99_scanf</span><br><span class="line">.text:08048696                 add     esp, 10h</span><br><span class="line">.text:08048699                 mov     [ebp+var_C], 0</span><br><span class="line">.text:080486A0                 jmp     short loc_8048706</span><br><span class="line">.text:080486A2 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:080486A2</span><br><span class="line">.text:080486A2 loc_80486A2:                            ; CODE XREF: main+FE↓j</span><br><span class="line">.text:080486A2                 mov     edx, ds:buffer0</span><br><span class="line">.text:080486A8                 mov     eax, [ebp+var_C]</span><br><span class="line">.text:080486AB                 lea     ebx, [edx+eax]</span><br><span class="line">.text:080486AE                 mov     edx, ds:buffer0</span><br><span class="line">.text:080486B4                 mov     eax, [ebp+var_C]</span><br><span class="line">.text:080486B7                 add     eax, edx</span><br><span class="line">.text:080486B9                 movzx   eax, byte ptr [eax]</span><br><span class="line">.text:080486BC                 movsx   eax, al</span><br><span class="line">.text:080486BF                 sub     esp, 8</span><br><span class="line">.text:080486C2                 push    [ebp+var_C]</span><br><span class="line">.text:080486C5                 push    eax</span><br><span class="line">.text:080486C6                 call    complex_function</span><br><span class="line">.text:080486CB                 add     esp, 10h</span><br><span class="line">.text:080486CE                 mov     [ebx], al</span><br><span class="line">.text:080486D0                 mov     edx, ds:buffer1</span><br><span class="line">.text:080486D6                 mov     eax, [ebp+var_C]</span><br><span class="line">.text:080486D9                 lea     ebx, [edx+eax]</span><br><span class="line">.text:080486DC                 mov     eax, [ebp+var_C]</span><br><span class="line">.text:080486DF                 lea     edx, [eax+20h]</span><br><span class="line">.text:080486E2                 mov     ecx, ds:buffer1</span><br><span class="line">.text:080486E8                 mov     eax, [ebp+var_C]</span><br><span class="line">.text:080486EB                 add     eax, ecx</span><br><span class="line">.text:080486ED                 movzx   eax, byte ptr [eax]</span><br><span class="line">.text:080486F0                 movsx   eax, al</span><br><span class="line">.text:080486F3                 sub     esp, 8</span><br><span class="line">.text:080486F6                 push    edx</span><br><span class="line">.text:080486F7                 push    eax</span><br><span class="line">.text:080486F8                 call    complex_function</span><br><span class="line">.text:080486FD                 add     esp, 10h</span><br><span class="line">.text:08048700                 mov     [ebx], al</span><br><span class="line">.text:08048702                 add     [ebp+var_C], 1</span><br><span class="line">.text:08048706</span><br></pre></td></tr></table></figure>

<p>再来看看complex的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">.text:080485A9 complex_function proc near              ; CODE XREF: main+BA↓p</span><br><span class="line">.text:080485A9                                         ; main+EC↓p</span><br><span class="line">.text:080485A9</span><br><span class="line">.text:080485A9 arg_0           = dword ptr  8</span><br><span class="line">.text:080485A9 arg_4           = dword ptr  0Ch</span><br><span class="line">.text:080485A9</span><br><span class="line">.text:080485A9 ; __unwind &#123;</span><br><span class="line">.text:080485A9                 push    ebp</span><br><span class="line">.text:080485AA                 mov     ebp, esp</span><br><span class="line">.text:080485AC                 sub     esp, 8</span><br><span class="line">.text:080485AF                 cmp     [ebp+arg_0], 40h ; &#x27;@&#x27;</span><br><span class="line">.text:080485B3                 jle     short loc_80485BB</span><br><span class="line">.text:080485B5                 cmp     [ebp+arg_0], 5Ah ; &#x27;Z&#x27;</span><br><span class="line">.text:080485B9                 jle     short loc_80485D5</span><br><span class="line">.text:080485BB</span><br><span class="line">.text:080485BB loc_80485BB:                            ; CODE XREF: complex_function+A↑j</span><br><span class="line">.text:080485BB                 sub     esp, 0Ch</span><br><span class="line">.text:080485BE                 push    offset s        ; &quot;Try again.&quot;</span><br><span class="line">.text:080485C3                 call    _puts</span><br><span class="line">.text:080485C8                 add     esp, 10h</span><br><span class="line">.text:080485CB                 sub     esp, 0Ch</span><br><span class="line">.text:080485CE                 push    1               ; status</span><br><span class="line">.text:080485D0                 call    _exit</span><br><span class="line">.text:080485D5 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:080485D5</span><br><span class="line">.text:080485D5 loc_80485D5:                            ; CODE XREF: complex_function+10↑j</span><br><span class="line">.text:080485D5                 mov     eax, [ebp+arg_0]</span><br><span class="line">.text:080485D8                 lea     ecx, [eax-41h]</span><br><span class="line">.text:080485DB                 mov     edx, [ebp+arg_4]</span><br><span class="line">.text:080485DE                 mov     eax, edx</span><br><span class="line">.text:080485E0                 add     eax, eax</span><br><span class="line">.text:080485E2                 add     eax, edx</span><br><span class="line">.text:080485E4                 shl     eax, 2</span><br><span class="line">.text:080485E7                 add     eax, edx</span><br><span class="line">.text:080485E9                 add     ecx, eax</span><br><span class="line">.text:080485EB                 mov     edx, 4EC4EC4Fh</span><br><span class="line">.text:080485F0                 mov     eax, ecx</span><br><span class="line">.text:080485F2                 imul    edx</span><br><span class="line">.text:080485F4                 sar     edx, 3</span><br><span class="line">.text:080485F7                 mov     eax, ecx</span><br><span class="line">.text:080485F9                 sar     eax, 1Fh</span><br><span class="line">.text:080485FC                 sub     edx, eax</span><br><span class="line">.text:080485FE                 mov     eax, edx</span><br><span class="line">.text:08048600                 imul    eax, 1Ah</span><br><span class="line">.text:08048603                 sub     ecx, eax</span><br><span class="line">.text:08048605                 mov     eax, ecx</span><br><span class="line">.text:08048607                 add     eax, 41h ; &#x27;A&#x27;</span><br><span class="line">.text:0804860A                 leave</span><br><span class="line">.text:0804860B                 retn</span><br><span class="line">.text:0804860B ; &#125; // starts at 80485A9</span><br><span class="line">.text:0804860B complex_function endp</span><br></pre></td></tr></table></figure>

<p>本题跟上面一题脚本的主要区别在于，要设置数据保存的地址。而malloc是在堆区中分配的，而没有明确地址。故脚本中我们要指出地址来存放数据（随意指定，只要不在代码区等影响程序运行的地方就行）。以及需要指定数据在内存中是以小端序存储的（angr默认是大端序）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">project =angr.Project(<span class="string">&quot;E:\\LAB\\angr\\angr\program\\06_angr_symbolic_dynamic_memory&quot;</span>)</span><br><span class="line"></span><br><span class="line">start_addr = <span class="number">0x08048699</span></span><br><span class="line">initial_state = project.factory.blank_state(addr=start_addr)</span><br><span class="line"></span><br><span class="line">password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">fake0_addr = <span class="number">0x4444440</span></span><br><span class="line">fake1_addr = <span class="number">0x4444450</span></span><br><span class="line"></span><br><span class="line">buffer0_addr = <span class="number">0x09FD92AC</span> </span><br><span class="line">buffer1_addr = <span class="number">0x09FD92B4</span></span><br><span class="line">initial_state.memory.store(buffer0_addr,fake0_addr,endness=project.arch.memory_endness)<span class="comment">#endness=...就是指定存储端序 </span></span><br><span class="line">initial_state.memory.store(buffer1_addr,fake1_addr,endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">initial_state.memory.store(fake0_addr, password0)</span><br><span class="line">initial_state.memory.store(fake1_addr, password1)</span><br><span class="line"></span><br><span class="line">simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">should_abort</span>(<span class="params">state</span>):</span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    solution0 = solution_state.se.<span class="built_in">eval</span>(password0)</span><br><span class="line">    solution1 = solution_state.se.<span class="built_in">eval</span>(password1)</span><br><span class="line">    solution = <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="string">&#x27;&#123;:x&#125;&#x27;</span>.<span class="built_in">format</span>, [ solution0, solution1 ]))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The Answer is :&#123;&#125;&quot;</span>.<span class="built_in">format</span>(solution))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No Answer!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="07-angr-symbolic-file"><a href="#07-angr-symbolic-file" class="headerlink" title="07_angr_symbolic_file"></a>07_angr_symbolic_file</h2><p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220312112246653.png" alt="image-20220312112246653"></p>
<p>伪代码整体逻辑为输入数据后，经过ignoerme处理，并保存在文件里MRXJ…txt，然后读取文件的数据，经过计算然后比较。</p>
<p>再看看ignoreme的伪代码</p>
<p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220312113844308.png" alt="image-20220312113844308"></p>
<p>main函数部分汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.text:080488B2                 push    offset buffer</span><br><span class="line">.text:080488B7                 push    offset a64s     ; &quot;%64s&quot;</span><br><span class="line">.text:080488BC                 call    ___isoc99_scanf</span><br><span class="line">.text:080488C1                 add     esp, 10h</span><br><span class="line">.text:080488C4                 sub     esp, 8</span><br><span class="line">.text:080488C7                 push    40h ; &#x27;@&#x27;       ; n</span><br><span class="line">.text:080488C9                 push    offset buffer   ; int</span><br><span class="line">.text:080488CE                 call    ignore_me</span><br><span class="line">.text:080488D3                 add     esp, 10h</span><br><span class="line">.text:080488D6                 sub     esp, 4</span><br><span class="line">.text:080488D9                 push    40h ; &#x27;@&#x27;       ; n</span><br><span class="line">.text:080488DB                 push    0               ; c</span><br><span class="line">.text:080488DD                 push    offset buffer   ; s</span><br><span class="line">.text:080488E2                 call    _memset</span><br><span class="line">.text:080488E7                 add     esp, 10h</span><br><span class="line">.text:080488EA                 sub     esp, 8</span><br><span class="line">.text:080488ED                 push    offset aRb      ; &quot;rb&quot;</span><br><span class="line">.text:080488F2                 push    offset name     ; &quot;MRXJKZYR.txt&quot;</span><br><span class="line">.text:080488F7                 call    _fopen</span><br><span class="line">.text:080488FC                 add     esp, 10h</span><br><span class="line">.text:080488FF                 mov     ds:fp, eax</span><br><span class="line">.text:08048904                 mov     eax, ds:fp</span><br><span class="line">.text:08048909                 push    eax             ; stream</span><br><span class="line">.text:0804890A                 push    40h ; &#x27;@&#x27;       ; n</span><br><span class="line">.text:0804890C                 push    1               ; size</span><br><span class="line">.text:0804890E                 push    offset buffer   ; ptr</span><br><span class="line">.text:08048913                 call    _fread</span><br><span class="line">.text:08048918                 add     esp, 10h</span><br><span class="line">.text:0804891B                 mov     eax, ds:fp</span><br><span class="line">.text:08048920                 sub     esp, 0Ch</span><br><span class="line">.text:08048923                 push    eax             ; stream</span><br><span class="line">.text:08048924                 call    _fclose</span><br><span class="line">.text:08048929                 add     esp, 10h</span><br><span class="line">.text:0804892C                 sub     esp, 0Ch</span><br><span class="line">.text:0804892F                 push    offset name     ; &quot;MRXJKZYR.txt&quot;</span><br><span class="line">.text:08048934                 call    _unlink</span><br><span class="line">.text:08048939                 add     esp, 10h</span><br><span class="line">.text:0804893C                 mov     [ebp+var_C], 0</span><br><span class="line">.text:08048943                 jmp     short loc_8048972</span><br><span class="line">.text:08048945 ; ----------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">project =angr.Project(<span class="string">&quot;E:\\LAB\\angr\\angr\program\\07_angr_symbolic_file&quot;</span>)</span><br><span class="line"></span><br><span class="line">start_addr = <span class="number">0x080488EA</span><span class="comment">#这个位置并没有符号化文件名</span></span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;MRXJKZYR.txt&#x27;</span> </span><br><span class="line">symbolic_file_size_bytes = <span class="number">64</span> </span><br><span class="line"></span><br><span class="line">password = claripy.BVS(<span class="string">&#x27;password&#x27;</span>, symbolic_file_size_bytes * <span class="number">8</span>) </span><br><span class="line">password_file = angr.SimFile(filename, content=password, size=symbolic_file_size_bytes) </span><br><span class="line"><span class="comment">#模拟读取文件</span></span><br><span class="line"></span><br><span class="line">initial_state = project.factory.blank_state(addr=start_addr,fs&#123;filename:password_file&#125;) <span class="comment">#构建状态上下文里的文件数据系统</span></span><br><span class="line">simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">should_abort</span>(<span class="params">state</span>):</span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    solution = long_to_bytes(solution_state.solver.<span class="built_in">eval</span>(password))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The Answer is :&#123;&#125;&quot;</span>.<span class="built_in">format</span>(solution))</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No Answer!&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="08-angr-constraints"><a href="#08-angr-constraints" class="headerlink" title="08_angr_constraints"></a>08_angr_constraints</h2><p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220312115905211.png" alt="image-20220312115905211"></p>
<p>惯例伪代码</p>
<p>逻辑很简单输入数据经过变化后与passwd比较，不过是在函数中比较。</p>
<p>main部分汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">.text:08048603                 push    offset aEnterThePasswo ; &quot;Enter the password: &quot;</span><br><span class="line">.text:08048608                 call    _printf</span><br><span class="line">.text:0804860D                 add     esp, 10h</span><br><span class="line">.text:08048610                 sub     esp, 8</span><br><span class="line">.text:08048613                 push    offset buffer</span><br><span class="line">.text:08048618                 push    offset a16s     ; &quot;%16s&quot;</span><br><span class="line">.text:0804861D                 call    ___isoc99_scanf</span><br><span class="line">.text:08048622                 add     esp, 10h</span><br><span class="line">.text:08048625                 mov     [ebp+var_C], 0</span><br><span class="line">.text:0804862C                 jmp     short loc_8048663</span><br><span class="line">.text:0804862E ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0804862E</span><br><span class="line">.text:0804862E loc_804862E:                            ; CODE XREF: main+B4↓j</span><br><span class="line">.text:0804862E                 mov     eax, 0Fh</span><br><span class="line">.text:08048633                 sub     eax, [ebp+var_C]</span><br><span class="line">.text:08048636                 mov     edx, eax</span><br><span class="line">.text:08048638                 mov     eax, [ebp+var_C]</span><br><span class="line">.text:0804863B                 add     eax, 804A050h</span><br><span class="line">.text:08048640                 movzx   eax, byte ptr [eax]</span><br><span class="line">.text:08048643                 movsx   eax, al</span><br><span class="line">.text:08048646                 sub     esp, 8</span><br><span class="line">.text:08048649                 push    edx</span><br><span class="line">.text:0804864A                 push    eax</span><br><span class="line">.text:0804864B                 call    complex_function</span><br><span class="line">.text:08048650                 add     esp, 10h</span><br><span class="line">.text:08048653                 mov     edx, eax</span><br><span class="line">.text:08048655                 mov     eax, [ebp+var_C]</span><br><span class="line">.text:08048658                 add     eax, 804A050h</span><br><span class="line">.text:0804865D                 mov     [eax], dl</span><br><span class="line">.text:0804865F                 add     [ebp+var_C], 1</span><br><span class="line">.text:08048663</span><br><span class="line">.text:08048663 loc_8048663:                            ; CODE XREF: main+79↑j</span><br><span class="line">.text:08048663                 cmp     [ebp+var_C], 0Fh</span><br><span class="line">.text:08048667                 jle     short loc_804862E</span><br><span class="line">.text:08048669                 sub     esp, 8</span><br><span class="line">.text:0804866C                 push    10h</span><br><span class="line">.text:0804866E                 push    offset buffer</span><br><span class="line">.text:08048673                 call    check_equals_MRXJKZYRKMKENFZB</span><br><span class="line">.text:08048678                 add     esp, 10h</span><br><span class="line">.text:0804867B                 test    eax, eax</span><br><span class="line">.text:0804867D                 jnz     short loc_8048691</span><br><span class="line">.text:0804867F                 sub     esp, 0Ch</span><br><span class="line">.text:08048682                 push    offset s        ; &quot;Try again.&quot;</span><br><span class="line">.text:08048687                 call    _puts</span><br><span class="line">.text:0804868C                 add     esp, 10h</span><br><span class="line">.text:0804868F                 jmp     short loc_80486A1</span><br><span class="line">.text:08048691 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:08048691</span><br><span class="line">.text:08048691 loc_8048691:                            ; CODE XREF: main+CA↑j</span><br><span class="line">.text:08048691                 sub     esp, 0Ch</span><br><span class="line">.text:08048694                 push    offset aGoodJob ; &quot;Good Job.&quot;</span><br><span class="line">.text:08048699                 call    _puts</span><br><span class="line">.text:0804869E                 add     esp, 10h</span><br></pre></td></tr></table></figure>

<p>complex的代码跟刚开始两道差不多，就不放了</p>
<p>思路：</p>
<p>开始地址还是设在输入后调用complex前，0x8048625</p>
<p>然后构造输入，从后面的比较函数的参数来看，buffer是16（0x10）个字节，80比特大小。再者就是buffer的地址</p>
<p>然后是循环的计算，在8048669位置结束，从下一行开始，就是往检查函数传参了。</p>
<p>需要注意的是，在检查函数里，是一个一个字符进行比较，这样就会让程序每次执行if语句16次，然后计算该走的分支，如此一算就是2^16，这就会产生路径爆炸问题。故，通过添加约束条件来避免这个问题。</p>
<p>列出脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">project =angr.Project(<span class="string">&quot;E:\\LAB\\angr\\angr\program\\08_angr_constraints&quot;</span>)</span><br><span class="line"></span><br><span class="line">start_addr = <span class="number">0x08048625</span> </span><br><span class="line">initial_state = project.factory.blank_state(addr=start_addr)</span><br><span class="line"></span><br><span class="line">buffer = claripy.BVS(<span class="string">&#x27;buffer&#x27;</span>, <span class="number">16</span>*<span class="number">8</span>)</span><br><span class="line">buffer_addr = <span class="number">0x0804A050</span></span><br><span class="line">initial_state.memory.store(buffer_addr, buffer)</span><br><span class="line"></span><br><span class="line">simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">addr_to_check_constraint = <span class="number">0x08048669</span> </span><br><span class="line">simulation.explore(find=addr_to_check_constraint)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        constrained_parameter_addr = <span class="number">0x0804A050</span> </span><br><span class="line">        constrained_parameter_size_bytes = <span class="number">16</span>   </span><br><span class="line">        constrained_parameter_bitvector = solution_state.memory.load(constrained_parameter_addr, constrained_parameter_size_bytes)  <span class="comment"># 从内存中加载buffer</span></span><br><span class="line"></span><br><span class="line">        constrained_parameter_desired_value = <span class="string">&#x27;MRXJKZYRKMKENFZB&#x27;</span> </span><br><span class="line"></span><br><span class="line">        constrained_expression = constrained_parameter_bitvector == constrained_parameter_desired_value                               <span class="comment"># 约束表达式</span></span><br><span class="line"></span><br><span class="line">        solution_state.add_constraints(constrained_expression)    <span class="comment"># 添加约束</span></span><br><span class="line"></span><br><span class="line">        solution = long_to_bytes(solution_state.se.<span class="built_in">eval</span>(buffer))</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The ANSWER is :&#123;&#125;&quot;</span>.<span class="built_in">format</span>(solution.decode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">&quot;No Answer!&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="09-angr-hooks"><a href="#09-angr-hooks" class="headerlink" title="09_angr_hooks"></a>09_angr_hooks</h2><p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220312155034471.png" alt="image-20220312155034471"></p>
<p>程序逻辑大致为先后输入两个数据，各自经过一系列变化，然后比较。</p>
<p>可以看到本题依旧有同样的检查函数，那么同上题一样，相同原理也会产生路径爆炸问题，本题如其名，我们通过angr的hook来避免路径爆炸，所以，我们钩取检查函数，定义一个自己的检查函数来作为替换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">project =angr.Project(<span class="string">&quot;E:\\LAB\\angr\\angr\program\\09_angr_hooks&quot;</span>)</span><br><span class="line"></span><br><span class="line">initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">check_equals_called_address = <span class="number">0x80486B3</span>  <span class="comment">#  检查函数地址</span></span><br><span class="line">instruction_to_skip_length = <span class="number">0x5</span>         <span class="comment">#  call check_equals_MRXJKZYRKMKENFZB这条指令的长度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@project.hook(<span class="params">check_equals_called_address, length=instruction_to_skip_length</span>)</span><span class="comment">#钩取</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">skip_check_equals_</span>(<span class="params">state</span>):</span><br><span class="line">    user_input_buffer_address = <span class="number">0x804A054</span>  <span class="comment">#  输入的地址</span></span><br><span class="line">    user_input_buffer_length = <span class="number">0x10</span>        <span class="comment">#  输入的长度</span></span><br><span class="line"></span><br><span class="line">    user_input_string = state.memory.load( <span class="comment">#  加载输入的数据</span></span><br><span class="line">      user_input_buffer_address,</span><br><span class="line">      user_input_buffer_length</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    check_against_string = <span class="string">&#x27;MRXJKZYRKMKENFZB&#x27;</span> </span><br><span class="line"></span><br><span class="line">    state.regs.eax = claripy.If(           <span class="comment">#  添加约束</span></span><br><span class="line">      user_input_string == check_against_string,  <span class="comment">#  条件</span></span><br><span class="line">      claripy.BVV(<span class="number">1</span>, <span class="number">32</span>),                  <span class="comment">#  真则返回 </span></span><br><span class="line">      claripy.BVV(<span class="number">0</span>, <span class="number">32</span>)                   <span class="comment">#  假则0</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Good Job&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">should_abort</span>(<span class="params">state</span>):</span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Try again&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line">simulation.explore(find=is_successful, avoid=should_abort) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    solution = solution_state.posix.dumps(sys.stdin.fileno()) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The ANSWER is :&#123;&#125;&quot;</span>.<span class="built_in">format</span>(solution.decode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No Answer!&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="10-angr-simprocedures"><a href="#10-angr-simprocedures" class="headerlink" title="10_angr_simprocedures"></a>10_angr_simprocedures</h2><p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220312163054462.png" alt="image-20220312163054462"></p>
<p>程序逻辑大同小异，不说了。</p>
<p>虽然说上一道和这一道没放汇编代码，但还是要看的，比如这道</p>
<p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220312164107756.png" alt="image-20220312164107756"></p>
<p>可以看到检查函数被调用了多次，那么我们无法通过准确的地址来进行钩取，故，我们需要通过函数名来钩取。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">project =angr.Project(<span class="string">&quot;E:\\LAB\\angr\\angr\program\\10_angr_simprocedures&quot;</span>)</span><br><span class="line"></span><br><span class="line">initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplacementCheckEquals</span>(angr.SimProcedure):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, check_data_address, check_data_length</span>):  <span class="comment">#参数后俩个是要hook函数的参数</span></span><br><span class="line">      check_input_string = self.state.memory.load(</span><br><span class="line">        check_data_address,</span><br><span class="line">        check_data_length</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      check_against_string = <span class="string">&#x27;MRXJKZYRKMKENFZB&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> claripy.If(check_input_string == check_against_string, claripy.BVV(<span class="number">1</span>, <span class="number">32</span>), claripy.BVV(<span class="number">0</span>, <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">check_equals_symbol = <span class="string">&#x27;check_equals_MRXJKZYRKMKENFZB&#x27;</span> </span><br><span class="line">project.hook_symbol(check_equals_symbol, ReplacementCheckEquals())  <span class="comment">#通过函数名钩取检查函数并替换为我们的检查函数</span></span><br><span class="line"></span><br><span class="line">simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Good Job&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">should_abort</span>(<span class="params">state</span>):</span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Try again&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line">simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    solution = solution_state.posix.dumps(sys.stdin.fileno())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The ANSWER is :&#123;&#125;&quot;</span>.<span class="built_in">format</span>(solution.decode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No Answer!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>本题脚本与上一题整体差别不大。主要在函数钩取方式上。</p>
<h2 id="11-angr-sim-scanf"><a href="#11-angr-sim-scanf" class="headerlink" title="11_angr_sim_scanf"></a>11_angr_sim_scanf</h2><p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220312164721082.png" alt="image-20220312164721082"></p>
<p>程序逻辑很明了，将原有数据变化，然后输入两个数据（每个四字节）与变化的数据作比较。</p>
<p>查看汇编代码发现，有多次调用输入函数，并比较的代码。这就是本题的关键点。</p>
<p>其实跟上一题差不多，这次很多调用的是输入，不是检查，相同的方法，钩取输入函数。不过参数设置上需要注意，数据大小，以及将数据以小端形式保存到地址中。并且需要将两个输入数据设置为全局变量。（需要重新设置两个变量来存储，因为我们在函数中设置的只是自定义的输入函数的局部变量，要想传到main中，得设置全局变量）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">project =angr.Project(<span class="string">&quot;E:\\LAB\\angr\\angr\program\\11_angr_sim_scanf&quot;</span>)</span><br><span class="line"></span><br><span class="line">initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplacementScanf</span>(angr.SimProcedure):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, format_string, scanf0_address, scanf1_address </span>):</span><br><span class="line">      scanf0 = claripy.BVS(<span class="string">&#x27;scanf0&#x27;</span>, <span class="number">4</span> * <span class="number">8</span>)<span class="comment">#4字节，32比特</span></span><br><span class="line">      scanf1 = claripy.BVS(<span class="string">&#x27;scanf1&#x27;</span>, <span class="number">4</span> * <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">      self.state.memory.store(scanf0_address, scanf0, endness=project.arch.memory_endness)<span class="comment">#保存到内存中</span></span><br><span class="line">      self.state.memory.store(scanf1_address, scanf1, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>] = scanf0<span class="comment">#全局变量的设置</span></span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>] = scanf1</span><br><span class="line"></span><br><span class="line">scanf_symbol = <span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">project.hook_symbol(scanf_symbol, ReplacementScanf())</span><br><span class="line"></span><br><span class="line">simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Good Job&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">should_abort</span>(<span class="params">state</span>):</span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Try again&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line">simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    stored_solutions0 = solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>]</span><br><span class="line">    stored_solutions1 = solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>]</span><br><span class="line">    solution0 = solution_state.se.<span class="built_in">eval</span>(stored_solutions0)</span><br><span class="line">    solution1 = solution_state.se.<span class="built_in">eval</span>(stored_solutions1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The ANSWER is :&#123;&#125;&quot;</span>.<span class="built_in">format</span>(solution0))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The ANSWER is :&#123;&#125;&quot;</span>.<span class="built_in">format</span>(solution1))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No Answer!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="12-angr-veritesting"><a href="#12-angr-veritesting" class="headerlink" title="12_angr_veritesting"></a>12_angr_veritesting</h2><p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220312170347821.png" alt="image-20220312170347821"></p>
<p>输入数据，经过祖传complex函数变化，然后作比较。</p>
<p>其实这个for循环和if语句加起来相当于一个检查函数，而且会执行2^32次，路径爆炸是必须的。</p>
<p>这题除了避免路径爆炸外，其余的跟刚开始几道题差不多。</p>
<p>放脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">project =angr.Project(<span class="string">&quot;E:\\LAB\\angr\\angr\program\\12_angr_veritesting&quot;</span>)</span><br><span class="line"></span><br><span class="line">initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">simulation = project.factory.simgr(initial_state,veritesting = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">  stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)  <span class="comment"># :boolean</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">should_abort</span>(<span class="params">state</span>):</span><br><span class="line">  stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Try again.&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)  <span class="comment"># :boolean</span></span><br><span class="line"></span><br><span class="line">simulation.explore(find = is_successful,avoid = should_abort)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found :</span><br><span class="line">  solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">  <span class="built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No Answer!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>本题主要是利用了project.factory.simgr() 函数提供的veritesting 参数来指定是否自动合并路径。</p>
<p>贴上大佬的简单原理解释</p>
<p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220312172250586.png" alt="image-20220312172250586"></p>
<h2 id="13-angr-static-binary"><a href="#13-angr-static-binary" class="headerlink" title="13_angr_static_binary"></a>13_angr_static_binary</h2><p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220312172829883.png" alt="image-20220312172829883"></p>
<p>伪代码如上。也是祖传complex函数变化。</p>
<p>乍一看，跟第一题还很像。但是用第一题的脚本跑半天出不来。而且还报错。</p>
<p>点进printf，scanf这类函数可以发现，呈现的是函数的源代码，不再是之前的跳转命令。</p>
<p>这个程序是静态链接编译的，故才会包含printf，scanf这类libc函数的实现。</p>
<p>因此我们需要hook掉这些实现的libc函数，避免angr在这些libc函数里东跑西跑迷失。</p>
<p>本题的libc函数有printf，scanf，puts，还有一个glibc函数__libc_start_main</p>
<p>hook掉之后，脚本就跟第一题的一样了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">project =angr.Project(<span class="string">&quot;E:\\LAB\\angr\\angr\program\\13_angr_static_binary&quot;</span>)</span><br><span class="line"></span><br><span class="line">initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">simulation = project.factory.simgr(initial_state,veritesting = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">project.hook(<span class="number">0x804ed40</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;printf&#x27;</span>]()) <span class="comment"># 获取Angr 内部实现的系统函数</span></span><br><span class="line">project.hook(<span class="number">0x804ed80</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;scanf&#x27;</span>]())</span><br><span class="line">project.hook(<span class="number">0x804f350</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;puts&#x27;</span>]())</span><br><span class="line">project.hook(<span class="number">0x8048d10</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;glibc&#x27;</span>][<span class="string">&#x27;__libc_start_main&#x27;</span>]())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">  stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">should_abort</span>(<span class="params">state</span>):</span><br><span class="line">  stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Try again.&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output) </span><br><span class="line"></span><br><span class="line">simulation.explore(find = is_successful,avoid = should_abort)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found :</span><br><span class="line">  solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">  <span class="built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No Answer!&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="14-angr-shared-library"><a href="#14-angr-shared-library" class="headerlink" title="14_angr_shared_library"></a>14_angr_shared_library</h2><p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220312180011638.png" alt="image-20220312180011638"></p>
<p>…….</p>
<p>这题还有一个对应的.so文件，这就需要用angr来动态链接了。</p>
<p>反编译的时候会报错，寄。</p>
<p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220312180837996.png" alt="image-20220312180837996"></p>
<p>原因摘自其他大神博客</p>
<p>这是因为generate.py 里面有一个Bug ,在最后的一个gcc 编译命令因为-L 参数缺少了指定当前目录,导致在寻找lib14_angr_shared_library.so 的时候找到了系统库目录,所以gcc 抛出了这个找不到<code>14_angr_shared_library: No such file or directory</code> 的问题,代码修改如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">with</span> tempfile.NamedTemporaryFile(delete=<span class="literal">False</span>, suffix=<span class="string">&#x27;.c&#x27;</span>) <span class="keyword">as</span> temp:</span><br><span class="line">    temp.write(c_code)</span><br><span class="line">    temp.seek(<span class="number">0</span>)</span><br><span class="line">-    os.system(<span class="string">&#x27;gcc -m32 -I . -L &#x27;</span> + <span class="string">&#x27;/&#x27;</span>.join(output_file.split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">0</span>:-<span class="number">1</span>]) + <span class="string">&#x27; -o &#x27;</span> + output_file + <span class="string">&#x27; &#x27;</span> + temp.name + <span class="string">&#x27; -l&#x27;</span> + output_file.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>])</span><br><span class="line">+    os.system(<span class="string">&#x27;gcc -m32 -I . -L . &#x27;</span> + <span class="string">&#x27;/&#x27;</span>.join(output_file.split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">0</span>:-<span class="number">1</span>]) + <span class="string">&#x27; -o &#x27;</span> + output_file + <span class="string">&#x27; &#x27;</span> + temp.name + <span class="string">&#x27; -l&#x27;</span> + output_file.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>回到函数本身，这个validate是验证函数哈，但是不在v这个程序里，在.so文件动态链接着</p>
<p>所以我们用IDA打开.so文件，查看validate代码。</p>
<p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220312181720370.png" alt="image-20220312181710748"></p>
<p>…祖传complex，没什么好说的。</p>
<p>这题考点在于这个动态链接。我们对这个.so文件进行符号执行。（加载文件时加载.so文件）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> msilib.schema <span class="keyword">import</span> Binary</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">base = <span class="number">0x400000</span>  <span class="comment">#  base 基址是随意定的,可以随意修改</span></span><br><span class="line">project = angr.Project(<span class="string">&quot;E:\\LAB\\angr\\angr\program\\lib14_angr_shared_library.so&quot;</span>, load_options=&#123;</span><br><span class="line">    <span class="string">&#x27;main_opts&#x27;</span> : &#123;</span><br><span class="line">      <span class="string">&#x27;custom_base_addr&#x27;</span> : base</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">buf_pointer = claripy.BVV(<span class="number">0x03000000</span>, <span class="number">32</span>)  <span class="comment"># 变量地址</span></span><br><span class="line">validate_addr = base+<span class="number">0x6d7</span>                 <span class="comment"># 函数地址</span></span><br><span class="line"><span class="comment"># validate(char* buffer, int length)</span></span><br><span class="line">init_state = project.factory.call_state(validate_addr, buf_pointer, claripy.BVV(<span class="number">8</span>, <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">flag = claripy.BVS(<span class="string">&quot;flag&quot;</span>, <span class="number">8</span>*<span class="number">8</span>)            <span class="comment"># 要求解的输入</span></span><br><span class="line">init_state.memory.store(buf_pointer, flag)</span><br><span class="line"></span><br><span class="line">good = base+<span class="number">0x783</span>  <span class="comment"># validate返回地址</span></span><br><span class="line">simu = project.factory.simgr(init_state)</span><br><span class="line">simu.explore(find=good)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simu.found:</span><br><span class="line">    solu_state = simu.found[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 限制返回时的寄存器值不为0才是正确结果</span></span><br><span class="line">    solu_state.add_constraints(solu_state.regs.eax != <span class="number">0</span>)</span><br><span class="line">    flag = solu_state.solver.<span class="built_in">eval</span>(flag, cast_to=<span class="built_in">bytes</span>)</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No result!&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="15-angr-arbitrary-read"><a href="#15-angr-arbitrary-read" class="headerlink" title="15_angr_arbitrary_read"></a>15_angr_arbitrary_read</h2><p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220312183629337.png" alt="image-20220312183629337"></p>
<p>接下来重点看汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">.text:080484C9 main            proc near               ; DATA XREF: _start+17↑o</span><br><span class="line">.text:080484C9</span><br><span class="line">.text:080484C9 var_1C          = byte ptr -1Ch</span><br><span class="line">.text:080484C9 s               = dword ptr -0Ch</span><br><span class="line">.text:080484C9 var_4           = dword ptr -4</span><br><span class="line">.text:080484C9 argc            = dword ptr  8</span><br><span class="line">.text:080484C9 argv            = dword ptr  0Ch</span><br><span class="line">.text:080484C9 envp            = dword ptr  10h</span><br><span class="line">.text:080484C9</span><br><span class="line">.text:080484C9 ; __unwind &#123;</span><br><span class="line">.text:080484C9                 lea     ecx, [esp+4]</span><br><span class="line">.text:080484CD                 and     esp, 0FFFFFFF0h</span><br><span class="line">.text:080484D0                 push    dword ptr [ecx-4]</span><br><span class="line">.text:080484D3                 push    ebp</span><br><span class="line">.text:080484D4                 mov     ebp, esp</span><br><span class="line">.text:080484D6                 push    ecx</span><br><span class="line">.text:080484D7                 sub     esp, 24h</span><br><span class="line">.text:080484DA                 mov     eax, try_again</span><br><span class="line">.text:080484DF                 mov     [ebp+s], eax</span><br><span class="line">.text:080484E2                 sub     esp, 0Ch</span><br><span class="line">.text:080484E5                 push    offset aEnterThePasswo ; &quot;Enter the password: &quot;</span><br><span class="line">.text:080484EA                 call    _printf</span><br><span class="line">.text:080484EF                 add     esp, 10h</span><br><span class="line">.text:080484F2                 sub     esp, 4</span><br><span class="line">.text:080484F5                 lea     eax, [ebp+var_1C]</span><br><span class="line">.text:080484F8                 push    eax</span><br><span class="line">.text:080484F9                 push    offset key</span><br><span class="line">.text:080484FE                 push    offset aU20s    ; &quot;%u %20s&quot;</span><br><span class="line">.text:08048503                 call    ___isoc99_scanf</span><br><span class="line">.text:08048508                 add     esp, 10h</span><br><span class="line">.text:0804850B                 mov     eax, ds:key</span><br><span class="line">.text:08048510                 cmp     eax, 228BF7Eh</span><br><span class="line">.text:08048515                 jz      short loc_8048531</span><br><span class="line">.text:08048517                 cmp     eax, 3AD516Ah</span><br><span class="line">.text:0804851C                 jnz     short loc_8048542</span><br><span class="line">.text:0804851E                 mov     eax, try_again</span><br><span class="line">.text:08048523                 sub     esp, 0Ch</span><br><span class="line">.text:08048526                 push    eax             ; s</span><br><span class="line">.text:08048527                 call    _puts</span><br><span class="line">.text:0804852C                 add     esp, 10h</span><br><span class="line">.text:0804852F                 jmp     short loc_8048553</span><br><span class="line">.text:08048531 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:08048531</span><br><span class="line">.text:08048531 loc_8048531:                            ; CODE XREF: main+4C↑j</span><br><span class="line">.text:08048531                 mov     eax, [ebp+s]</span><br><span class="line">.text:08048534                 sub     esp, 0Ch</span><br><span class="line">.text:08048537                 push    eax             ; s</span><br><span class="line">.text:08048538                 call    _puts</span><br><span class="line">.text:0804853D                 add     esp, 10h</span><br><span class="line">.text:08048540                 jmp     short loc_8048553</span><br><span class="line">.text:08048542 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:08048542</span><br><span class="line">.text:08048542 loc_8048542:                            ; CODE XREF: main+53↑j</span><br><span class="line">.text:08048542                 mov     eax, try_again</span><br><span class="line">.text:08048547                 sub     esp, 0Ch</span><br><span class="line">.text:0804854A                 push    eax             ; s</span><br><span class="line">.text:0804854B                 call    _puts</span><br><span class="line">.text:08048550                 add     esp, 10h</span><br><span class="line">.text:08048553</span><br><span class="line">.text:08048553 loc_8048553:                            ; CODE XREF: main+66↑j</span><br><span class="line">.text:08048553                                         ; main+77↑j</span><br><span class="line">.text:08048553                 nop</span><br><span class="line">.text:08048554                 mov     eax, 0</span><br><span class="line">.text:08048559                 mov     ecx, [ebp+var_4]</span><br><span class="line">.text:0804855C                 leave</span><br><span class="line">.text:0804855D                 lea     esp, [ecx-4]</span><br><span class="line">.text:08048560                 retn</span><br><span class="line">.text:08048560 ; &#125; // starts at 80484C9</span><br><span class="line">.text:08048560 main            endp</span><br></pre></td></tr></table></figure>

<p>输入的两个参数，key，v4，分别对应汇编代码中的s（var_c），var_1c，由此可见，两个参数相距0x10（16个字节大小，其实也就是说，var_1c（v4）是16个字节大小。）而输入会输入20个字节。必定会将key变量覆盖部分甚至全部。（其实%u就是占四个字节，这里key就刚好全部被覆盖了）</p>
<p>再会看程序逻辑，将key与0x228BF7E比较，相等则不输出tryagain，至此我们找到了输出s的方法</p>
<p>我们使用hook，钩取scanf</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> msilib.schema <span class="keyword">import</span> Binary</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">binary_path = <span class="string">&quot;E:\\LAB\\angr\\angr\program\\15_angr_arbitrary_read&quot;</span></span><br><span class="line">pro = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">init_state = pro.factory.entry_state()</span><br><span class="line"></span><br><span class="line"><span class="comment"># replace scanf</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplaceScanf</span>(angr.SimProcedure):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, format_str, param0, param1</span>):</span><br><span class="line">        scanf0 = claripy.BVS(<span class="string">&quot;0&quot;</span>, <span class="number">32</span>)</span><br><span class="line">        scanf1 = claripy.BVS(<span class="string">&quot;1&quot;</span>, <span class="number">20</span>*<span class="number">8</span>)</span><br><span class="line">        <span class="comment"># 限制单个字符的求解范围</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> scanf1.chop(bits=<span class="number">8</span>):</span><br><span class="line">            self.state.add_constraints(ch &gt;= <span class="string">&quot;A&quot;</span>, ch &lt;= <span class="string">&quot;Z&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.state.memory.store(param0, scanf0, endness=pro.arch.memory_endness)</span><br><span class="line">        self.state.memory.store(param1, scanf1)</span><br><span class="line">        self.state.<span class="built_in">globals</span>[<span class="string">&quot;solutions&quot;</span>] = (scanf0, scanf1)</span><br><span class="line"></span><br><span class="line">scanf_sym = <span class="string">&quot;__isoc99_scanf&quot;</span></span><br><span class="line">pro.hook_symbol(scanf_sym, ReplaceScanf())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过检查puts的输出来确定是否是想要的结果</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_puts</span>(<span class="params">state</span>):</span><br><span class="line">    puts_para = state.memory.load(state.regs.esp+<span class="number">4</span>, <span class="number">4</span>, endness=pro.arch.memory_endness)</span><br><span class="line">    <span class="keyword">if</span> state.solver.symbolic(puts_para):</span><br><span class="line">        good_str = <span class="number">0x4D52584B</span></span><br><span class="line">        copy_state = state.copy()</span><br><span class="line">        copy_state.add_constraints(puts_para == good_str)</span><br><span class="line">        <span class="keyword">if</span> copy_state.satisfiable():</span><br><span class="line">            <span class="comment"># 先通过拷贝的状态判断是否满足，然后再直接在原状态增加限制</span></span><br><span class="line">            state.add_constraints(puts_para == good_str) <span class="comment">#  如果有解的话就保存到我们执行的那个状态对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">success</span>(<span class="params">state</span>):</span><br><span class="line">    puts_plt = <span class="number">0x08048370</span> <span class="comment">#  当程序执行到puts() 函数时,我们就认为路径探索到了这里,然后再去通过check_puts() 判断这里是否存在漏洞,告诉Angr这是不是我们需要找的那条执行路径</span></span><br><span class="line">    <span class="keyword">if</span> state.addr == puts_plt:</span><br><span class="line">        <span class="keyword">return</span> check_puts(state)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">simu = pro.factory.simgr(init_state)</span><br><span class="line">simu.explore(find=success)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simu.found:</span><br><span class="line">    solu_state = simu.found[<span class="number">0</span>]</span><br><span class="line">    (scanf0, scanf1) = solu_state.<span class="built_in">globals</span>[<span class="string">&quot;solutions&quot;</span>]</span><br><span class="line">    flag = <span class="built_in">str</span>(solu_state.solver.<span class="built_in">eval</span>(scanf0)).encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    flag += <span class="string">b&quot; &quot;</span> + solu_state.solver.<span class="built_in">eval</span>(scanf1, cast_to=<span class="built_in">bytes</span>)</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No result!&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="16-angr-arbitrary-write"><a href="#16-angr-arbitrary-write" class="headerlink" title="16_angr_arbitrary_write"></a>16_angr_arbitrary_write</h2><p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220312190749217.png" alt="image-20220312190749217"></p>
<p>汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">.text:08048569 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:08048569                 public main</span><br><span class="line">.text:08048569 main            proc near               ; DATA XREF: _start+17↑o</span><br><span class="line">.text:08048569</span><br><span class="line">.text:08048569 input_buffer(s)    = byte ptr -1Ch</span><br><span class="line">.text:08048569 target_buffer(dest)   = dword ptr -0Ch</span><br><span class="line">.text:08048569 var_4           = dword ptr -4</span><br><span class="line">.text:08048569 argc            = dword ptr  8</span><br><span class="line">.text:08048569 argv            = dword ptr  0Ch</span><br><span class="line">.text:08048569 envp            = dword ptr  10h</span><br><span class="line">.text:08048569</span><br><span class="line">.text:08048569 ; __unwind &#123;</span><br><span class="line">.text:08048569                 lea     ecx, [esp+4]</span><br><span class="line">.text:0804856D                 and     esp, 0FFFFFFF0h</span><br><span class="line">.text:08048570                 push    dword ptr [ecx-4]</span><br><span class="line">.text:08048573                 push    ebp</span><br><span class="line">.text:08048574                 mov     ebp, esp</span><br><span class="line">.text:08048576                 push    ecx</span><br><span class="line">.text:08048577                 sub     esp, 24h</span><br><span class="line">.text:0804857A                 mov     [ebp+target_buffer], offset unimportant_buffer</span><br><span class="line">.text:08048581                 sub     esp, 4</span><br><span class="line">.text:08048584                 push    10h             ; n</span><br><span class="line">.text:08048586                 push    0               ; c</span><br><span class="line">.text:08048588                 lea     eax, [ebp+input_buffer]</span><br><span class="line">.text:0804858B                 push    eax             ; s</span><br><span class="line">.text:0804858C                 call    _memset         ;  清空input_buffer 的内容</span><br><span class="line">.text:08048591                 add     esp, 10h</span><br><span class="line">.text:08048594                 sub     esp, 4</span><br><span class="line">.text:08048597                 push    0Ch             ; n</span><br><span class="line">.text:08048599                 push    offset src      ; &quot;PASSWORD&quot;</span><br><span class="line">.text:0804859E                 push    offset password_buffer ; dest</span><br><span class="line">.text:080485A3                 call    _strncpy        ;  复制PASSWORD 到全局内存password_buffer</span><br><span class="line">.text:080485A8                 add     esp, 10h</span><br><span class="line">.text:080485AB                 sub     esp, 0Ch</span><br><span class="line">.text:080485AE                 push    offset aEnterThePasswo ; &quot;Enter the password: &quot;</span><br><span class="line">.text:080485B3                 call    _printf</span><br><span class="line">.text:080485B8                 add     esp, 10h</span><br><span class="line">.text:080485BB                 sub     esp, 4</span><br><span class="line">.text:080485BE                 lea     eax, [ebp+input_buffer]</span><br><span class="line">.text:080485C1                 push    eax</span><br><span class="line">.text:080485C2                 push    offset check_key</span><br><span class="line">.text:080485C7                 push    offset aU20s    ; &quot;%u %20s&quot;</span><br><span class="line">.text:080485CC                 call    ___isoc99_scanf  ;  scanf(&quot;%u %20s&quot;,check_key,input_buffer) .注意input_buffer 的大小是20 字节,栈上的input_buffer 默认的大小是16 字节,最后4 字节可以覆盖target_buffer .</span><br><span class="line">.text:080485D1                 add     esp, 10h</span><br><span class="line">.text:080485D4                 mov     eax, ds:check_key</span><br><span class="line">.text:080485D9                 cmp     eax, 1A25D71h</span><br><span class="line">.text:080485DE                 jz      short loc_80485E9</span><br><span class="line">.text:080485E0                 cmp     eax, 1CB7D43h</span><br><span class="line">.text:080485E5                 jz      short loc_8048601  ;  根据check_key 的输入来跳转到不同的_strncpy</span><br><span class="line">.text:080485E7                 jmp     short loc_8048618</span><br><span class="line">.text:080485E9 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:080485E9</span><br><span class="line">.text:080485E9 loc_80485E9:                            ; CODE XREF: main+75↑j</span><br><span class="line">.text:080485E9                 sub     esp, 4</span><br><span class="line">.text:080485EC                 push    10h             ; n</span><br><span class="line">.text:080485EE                 lea     eax, [ebp+input_buffer]</span><br><span class="line">.text:080485F1                 push    eax             ; src</span><br><span class="line">.text:080485F2                 push    offset unimportant_buffer ; dest</span><br><span class="line">.text:080485F7                 call    _strncpy</span><br><span class="line">.text:080485FC                 add     esp, 10h</span><br><span class="line">.text:080485FF                 jmp     short loc_804862E</span><br><span class="line">.text:08048601 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:08048601</span><br><span class="line">.text:08048601 loc_8048601:                            ; CODE XREF: main+7C↑j</span><br><span class="line">.text:08048601                 mov     eax, [ebp+target_buffer]  ;  注意这个是MOV 指令,意思是获取EBP + target_buffer 这个地址的内容保存到EAX 中</span><br><span class="line">.text:08048604                 sub     esp, 4</span><br><span class="line">.text:08048607                 push    10h             ; n</span><br><span class="line">.text:08048609                 lea     edx, [ebp+input_buffer]  ;  注意这个是LEA 指令,意思是计算出EBP + input_buffer 的地址保存到EBX 中</span><br><span class="line">.text:0804860C                 push    edx             ; src</span><br><span class="line">.text:0804860D                 push    eax             ; dest</span><br><span class="line">.text:0804860E                 call    _strncpy  ;  漏洞点在这里,strncpy(*target_buffer,input_buffer) ,也就是说input_buffer 最后四字节可以控制对任意地址的_strncpy() .总结起来就是strncpy(input_buffer[ -4 : ],input_buffer,0x10) .</span><br><span class="line">.text:08048613                 add     esp, 10h</span><br><span class="line">.text:08048616                 jmp     short loc_804862E</span><br><span class="line">.text:08048618 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:08048618</span><br><span class="line">.text:08048618 loc_8048618:                            ; CODE XREF: main+7E↑j</span><br><span class="line">.text:08048618                 sub     esp, 4</span><br><span class="line">.text:0804861B                 push    10h             ; n</span><br><span class="line">.text:0804861D                 lea     eax, [ebp+input_buffer]</span><br><span class="line">.text:08048620                 push    eax             ; src</span><br><span class="line">.text:08048621                 push    offset unimportant_buffer ; dest</span><br><span class="line">.text:08048626                 call    _strncpy</span><br><span class="line">.text:0804862B                 add     esp, 10h</span><br><span class="line">.text:0804862E</span><br><span class="line">.text:0804862E loc_804862E:                            ; CODE XREF: main+96↑j</span><br><span class="line">.text:0804862E                                         ; main+AD↑j</span><br><span class="line">.text:0804862E                 nop</span><br><span class="line">.text:0804862F                 sub     esp, 4</span><br><span class="line">.text:08048632                 push    8               ; n</span><br><span class="line">.text:08048634                 push    offset key_string       ; &quot;KZYRKMKE&quot;</span><br><span class="line">.text:08048639                 push    offset password_buffer ; s1</span><br><span class="line">.text:0804863E                 call    _strncmp        ;  我们知道了上面有一个任意地址写之后,我们就需要改写key_string 或者password_buffer 一致,让_strncmp() 返回0 ,跳转到puts(&quot;Good Job&quot;)</span><br><span class="line">.text:08048643                 add     esp, 10h</span><br><span class="line">.text:08048646                 test    eax, eax</span><br><span class="line">.text:08048648                 jz      short loc_804865C</span><br><span class="line">.text:0804864A                 sub     esp, 0Ch</span><br><span class="line">.text:0804864D                 push    offset s        ; &quot;Try again.&quot;</span><br><span class="line">.text:08048652                 call    _puts</span><br><span class="line">.text:08048657                 add     esp, 10h</span><br><span class="line">.text:0804865A                 jmp     short loc_804866C</span><br><span class="line">.text:0804865C ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0804865C</span><br><span class="line">.text:0804865C loc_804865C:                            ; CODE XREF: main+DF↑j</span><br><span class="line">.text:0804865C                 sub     esp, 0Ch</span><br><span class="line">.text:0804865F                 push    offset aGoodJob ; &quot;Good Job.&quot;</span><br><span class="line">.text:08048664                 call    _puts</span><br><span class="line">.text:08048669                 add     esp, 10h</span><br></pre></td></tr></table></figure>

<p>这题，s和key的关系跟上题v4和key的关系一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> msilib.schema <span class="keyword">import</span> Binary</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">binary_path = <span class="string">&quot;E:\\LAB\\angr\\angr\program\\16_angr_arbitrary_write&quot;</span></span><br><span class="line">project= angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplacementScanf</span>(angr.SimProcedure):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, format_string, check_key ,input_buffer</span>):</span><br><span class="line">      scanf0 = claripy.BVS(<span class="string">&#x27;scanf0&#x27;</span>, <span class="number">4</span> * <span class="number">8</span>)</span><br><span class="line">      scanf1 = claripy.BVS(<span class="string">&#x27;scanf1&#x27;</span>, <span class="number">20</span> * <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> char <span class="keyword">in</span> scanf1.chop(bits=<span class="number">8</span>):</span><br><span class="line">        self.state.add_constraints(char &gt;= <span class="string">&#x27;0&#x27;</span>, char &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      self.state.memory.store(check_key, scanf0, endness=project.arch.memory_endness)</span><br><span class="line">      self.state.memory.store(input_buffer, scanf1, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>] = scanf0</span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>] = scanf1</span><br><span class="line"></span><br><span class="line">scanf_symbol = <span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">project.hook_symbol(scanf_symbol, ReplacementScanf())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_strncpy</span>(<span class="params">state</span>):</span><br><span class="line">    strncpy_dest = state.memory.load(state.regs.esp + <span class="number">4</span>, <span class="number">4</span>, endness=project.arch.memory_endness)  <span class="comment">#  获取strncpy() 的参数,strncpy_dest ..</span></span><br><span class="line">    strncpy_src  = state.memory.load(state.regs.esp + <span class="number">8</span>, <span class="number">4</span>, endness=project.arch.memory_endness)</span><br><span class="line">    strncpy_len  = state.memory.load(state.regs.esp + <span class="number">12</span>, <span class="number">4</span>, endness=project.arch.memory_endness)</span><br><span class="line">    src_contents = state.memory.load(strncpy_src, strncpy_len)  <span class="comment">#  因为参数中只保存了地址,我们需要根据这个地址去获取内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> state.se.symbolic(strncpy_dest) <span class="keyword">and</span> state.se.symbolic(src_contents) :  <span class="comment">#  判断dest 和src 的内容是不是符号化对象</span></span><br><span class="line">      <span class="keyword">if</span> state.satisfiable(extra_constraints=(src_contents[ -<span class="number">1</span> : -<span class="number">64</span> ] == <span class="string">&#x27;KZYRKMKE&#x27;</span> ,strncpy_dest == <span class="number">0x4D52584C</span>)):  <span class="comment">#  尝试求解,其中strncpy_dest == 0x4D52584C 的意思是判断dest 是否可控为password 的地址;src_contents[ -1 : -64 ] == &#x27;KZYRKMKE&#x27; 是判断input_buffer 的内容是否可控为&#x27;KZYRKMKE&#x27; ,因为这块内存是倒序,所以需要通过[ -1 : -64 ] 倒转(contentes 的内容是比特,获取8 字节的大小为:8*8 = 64),然后判断该值是否为字符串&#x27;KZYRKMKE&#x27;</span></span><br><span class="line">        state.add_constraints(src_contents[ -<span class="number">1</span> : -<span class="number">64</span> ] == <span class="string">&#x27;KZYRKMKE&#x27;</span>,strncpy_dest == <span class="number">0x4D52584C</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">    strncpy_address = <span class="number">0x8048410</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> state.addr == strncpy_address:</span><br><span class="line">      <span class="keyword">return</span> check_strncpy(state)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">simulation.explore(find=is_successful)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    solution0 = solution_state.se.<span class="built_in">eval</span>(solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>])</span><br><span class="line">    solution1 = solution_state.se.<span class="built_in">eval</span>(solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>],cast_to=<span class="built_in">bytes</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(solution0,solution1)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No result!&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="17-angr-arbitrary-jump"><a href="#17-angr-arbitrary-jump" class="headerlink" title="17_angr_arbitrary_jump"></a>17_angr_arbitrary_jump</h2><p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220312192050484.png" alt="image-20220312192050484"></p>
<p><img src="/2022/03/08/angrLAB%E7%AC%94%E8%AE%B0/image-20220312192112152.png" alt="image-20220312192112152"></p>
<p>这么简单肯定出事儿，没有Goodjob。</p>
<p>汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.text:4D525886 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:4D525886                 public main</span><br><span class="line">.text:4D525886 main            proc near               ; DATA XREF: _start+17↑o</span><br><span class="line">.text:4D525886</span><br><span class="line">.text:4D525886 var_C           = dword ptr -0Ch</span><br><span class="line">.text:4D525886 var_4           = dword ptr -4</span><br><span class="line">.text:4D525886 argc            = dword ptr  8</span><br><span class="line">.text:4D525886 argv            = dword ptr  0Ch</span><br><span class="line">.text:4D525886 envp            = dword ptr  10h</span><br><span class="line">.text:4D525886</span><br><span class="line">.text:4D525886 ; __unwind &#123;</span><br><span class="line">.text:4D525886                 lea     ecx, [esp+4]</span><br><span class="line">.text:4D52588A                 and     esp, 0FFFFFFF0h</span><br><span class="line">.text:4D52588D                 push    dword ptr [ecx-4]</span><br><span class="line">.text:4D525890                 push    ebp</span><br><span class="line">.text:4D525891                 mov     ebp, esp</span><br><span class="line">.text:4D525893                 push    ecx</span><br><span class="line">.text:4D525894                 sub     esp, 14h</span><br><span class="line">.text:4D525897                 mov     [ebp+var_C], 0</span><br><span class="line">.text:4D52589E                 sub     esp, 0Ch</span><br><span class="line">.text:4D5258A1                 push    offset aEnterThePasswo ; &quot;Enter the password: &quot;</span><br><span class="line">.text:4D5258A6                 call    _printf</span><br><span class="line">.text:4D5258AB                 add     esp, 10h</span><br><span class="line">.text:4D5258AE                 call    read_input  ;  </span><br><span class="line">.text:4D5258B3                 sub     esp, 0Ch</span><br><span class="line">.text:4D5258B6                 push    offset aTryAgain ; &quot;Try again.&quot;</span><br><span class="line">.text:4D5258BB                 call    _puts</span><br><span class="line">.text:4D5258C0                 add     esp, 10h</span><br><span class="line">.text:4D5258C3                 mov     eax, 0</span><br><span class="line">.text:4D5258C8                 mov     ecx, [ebp+var_4]</span><br><span class="line">.text:4D5258CB                 leave</span><br><span class="line">.text:4D5258CC                 lea     esp, [ecx-4]</span><br><span class="line">.text:4D5258CF                 retn</span><br></pre></td></tr></table></figure>

<p>good job</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:4D525849 print_good      proc near</span><br><span class="line">.text:4D525849 ; __unwind &#123;</span><br><span class="line">.text:4D525849                 push    ebp</span><br><span class="line">.text:4D52584A                 mov     ebp, esp</span><br><span class="line">.text:4D52584C                 sub     esp, 8</span><br><span class="line">.text:4D52584F                 sub     esp, 0Ch</span><br><span class="line">.text:4D525852                 push    offset s        ; &quot;Good Job.&quot;</span><br><span class="line">.text:4D525857                 call    _puts</span><br><span class="line">.text:4D52585C                 add     esp, 10h</span><br><span class="line">.text:4D52585F                 sub     esp, 0Ch</span><br><span class="line">.text:4D525862                 push    0               ; status</span><br><span class="line">.text:4D525864                 call    _exit</span><br><span class="line">.text:4D525864 ; &#125; // starts at 4D525849</span><br><span class="line">.text:4D525864 print_good      endp</span><br></pre></td></tr></table></figure>

<p>reaad_input</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">read_input      proc near               ; CODE XREF: main+28↓p</span><br><span class="line">.text:4D525869</span><br><span class="line">.text:4D525869 var_2B          = byte ptr -2Bh</span><br><span class="line">.text:4D525869</span><br><span class="line">.text:4D525869 ; __unwind &#123;</span><br><span class="line">.text:4D525869                 push    ebp</span><br><span class="line">.text:4D52586A                 mov     ebp, esp</span><br><span class="line">.text:4D52586C                 sub     esp, 38h</span><br><span class="line">.text:4D52586F                 sub     esp, 8</span><br><span class="line">.text:4D525872                 lea     eax, [ebp+var_2B]</span><br><span class="line">.text:4D525875                 push    eax</span><br><span class="line">.text:4D525876                 push    offset format   ; &quot;%s&quot;</span><br><span class="line">.text:4D52587B                 call    ___isoc99_scanf</span><br><span class="line">.text:4D525880                 add     esp, 10h</span><br><span class="line">.text:4D525883                 nop</span><br><span class="line">.text:4D525884                 leave</span><br><span class="line">.text:4D525885                 retn</span><br><span class="line">.text:4D525885 ; &#125; // starts at 4D525869</span><br><span class="line">.text:4D525885 read_input      endp</span><br></pre></td></tr></table></figure>

<p>这道题和上面两道题其实是有相似之处的，输入的长度过长会造成溢出，会覆盖某些东西。</p>
<p>这个函数是当输入足够长时造成的栈溢出会覆盖retn的命令。</p>
<p>其实思路也已经出来了</p>
<p>我们hook输入函数，将输入的参数字节扩大，让它不覆盖retn</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> msilib.schema <span class="keyword">import</span> Binary</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">binary_path = <span class="string">&quot;E:\\LAB\\angr\\angr\program\\17_angr_arbitrary_jump&quot;</span></span><br><span class="line">project= angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">simulation = project.factory.simgr(</span><br><span class="line">    initial_state,</span><br><span class="line">    save_unconstrained=<span class="literal">True</span>,</span><br><span class="line">    stashes=&#123;</span><br><span class="line">      <span class="string">&#x27;active&#x27;</span> : [initial_state],</span><br><span class="line">      <span class="string">&#x27;unconstrained&#x27;</span> : [],</span><br><span class="line">      <span class="string">&#x27;found&#x27;</span> : [],</span><br><span class="line">      <span class="string">&#x27;not_needed&#x27;</span> : []</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplacementScanf</span>(angr.SimProcedure):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, format_string, input_buffer_address</span>):</span><br><span class="line">      input_buffer = claripy.BVS(<span class="string">&#x27;input_buffer&#x27;</span>, <span class="number">64</span> * <span class="number">8</span>)  <span class="comment">#  设置一个较大的input_buffer</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> char <span class="keyword">in</span> input_buffer.chop(bits=<span class="number">8</span>):</span><br><span class="line">        self.state.add_constraints(char &gt;= <span class="string">&#x27;0&#x27;</span>, char &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      self.state.memory.store(input_buffer_address, input_buffer, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution&#x27;</span>] = input_buffer</span><br><span class="line"></span><br><span class="line">scanf_symbol = <span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">project.hook_symbol(scanf_symbol, ReplacementScanf())  <span class="comment">#  对scanf() 做Hook</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (simulation.active <span class="keyword">or</span> simulation.unconstrained) <span class="keyword">and</span> (<span class="keyword">not</span> simulation.found):  <span class="comment">#  </span></span><br><span class="line">    <span class="keyword">for</span> unconstrained_state <span class="keyword">in</span> simulation.unconstrained:</span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">should_move</span>(<span class="params">s</span>):</span><br><span class="line">        <span class="keyword">return</span> s <span class="keyword">is</span> unconstrained_state</span><br><span class="line">      </span><br><span class="line">      simulation.move(<span class="string">&#x27;unconstrained&#x27;</span>, <span class="string">&#x27;found&#x27;</span>, filter_func=should_move)  <span class="comment">#  保存</span></span><br><span class="line"></span><br><span class="line">    simulation.step()  <span class="comment">#  步进执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    solution_state.add_constraints(solution_state.regs.eip == <span class="number">0x4D525849</span>)  <span class="comment">#  判断EIP 地址是否可控</span></span><br><span class="line"></span><br><span class="line">    solution = solution_state.se.<span class="built_in">eval</span>(solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution&#x27;</span>],cast_to = <span class="built_in">bytes</span>)  <span class="comment">#  生成Payload</span></span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>丫的，终于写完了</p>
<p>感觉这个实验写完，能入个门，更多的还是得多多琢磨官方文档。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2298233831.github.io/2022/02/28/Boomlab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yu4n">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Blog of Yu4n">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/28/Boomlab/" class="post-title-link" itemprop="url">Boomlab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-28 15:56:07" itemprop="dateCreated datePublished" datetime="2022-02-28T15:56:07+08:00">2022-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-01 13:13:22" itemprop="dateModified" datetime="2022-03-01T13:13:22+08:00">2022-03-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Boomlab"><a href="#Boomlab" class="headerlink" title="Boomlab"></a>Boomlab</h1><p>（感觉这个实验也可以直接丢进IDA当逆向做，相对简单；本次以汇编语言下手；所用工具为VS2022社区版）</p>
<p>先在Linux里用如下命令把文件反汇编出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d bomb &gt; bomb.asm</span><br></pre></td></tr></table></figure>

<p>查找到main函数方式多样,此处直接搜索main即可找到位置。</p>
<p><img src="/2022/02/28/Boomlab/image-20220228164722822.png" alt="image-20220228164722822"></p>
<p>大致浏览一遍main函数，有几个phase，就是需要拆除的炸弹了。</p>
<p>本文着重描述过程，运算只涉及最后的结果。</p>
<p>本文着重描述过程，运算只涉及最后的结果。</p>
<p>本文着重描述过程，运算只涉及最后的结果。（水平有限）</p>
<h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase_1"></a>Phase_1</h2><p>根据函数对应的地址跳转</p>
<p><img src="/2022/02/28/Boomlab/image-20220228165317069.png" alt="image-20220228165317069"></p>
<p>可以看到该函数中，先将一段地址赋给esi，然后调用strings_not_equal；然后测试eax值，为0就跳过了引爆炸弹的一步。由此可见关键在于strings_not_equal这个函数。</p>
<p><img src="/2022/02/28/Boomlab/image-20220228170012668.png" alt="image-20220228170012668"></p>
<p>可以看到还是比较长的，不过容易读懂。首先是传参，将rbx，rbp作为string_length的参数，然后调用。可以根据最开始的两个mov猜测，rdi，rsi就是string_not_equal的两个参数。</p>
<p>再看本函数结尾，会有一个给eax赋值的操作，然后返回。这时候就需要知道edx被赋了什么值。</p>
<p>浏览代码可以看出大致逻辑（也可以根据函数名直接猜）两参数的字符串相等则返回0，不相等则返回1</p>
<p>查看esi里的地址所对应的字符串如下：（用gdb调起来才能看到，不熟悉gdb也可以拖进IDA，看汇编还是伪代码就自己选择了）</p>
<p><img src="/2022/02/28/Boomlab/image-20220228174801745.png" alt="image-20220228174801745"></p>
<p>“Border relations with Canada have never been better.”</p>
<h2 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase_2"></a>Phase_2</h2><p>首先是代码</p>
<p><img src="/2022/02/28/Boomlab/image-20220228171547222.png" alt="image-20220228171547222"></p>
<p>可以看到调用read_six_numbers函数</p>
<p><img src="/2022/02/28/Boomlab/image-20220228172152067.png" alt="image-20220228172152067"></p>
<p>代码大致逻辑为读取6个数，没有六个就引爆炸弹。</p>
<p>接着看phase_2代码，将rsp的值与1作比较，不相等就爆；然后将rsp+0x4和rsp+0x18的值给了rbx，rbp然后是把rbx-0x4地址处的内容给了eax，然后eax+eax，再做比较，相等就不爆；再继续，将rbx值加4字节（一个int的大小），到了下一个数，再进行比较。依照逻辑，输入的六个数分别为：1 2 4 8 16 32.即可拆弹</p>
<h2 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase_3"></a>Phase_3</h2><p>代码</p>
<p><img src="/2022/02/28/Boomlab/image-20220228173849867.png" alt="image-20220228173849867"></p>
<p>先查看一下0x4025cf处是啥，结合下面的输入函数，这是两个输入的参数。这里可以假设一下rcx和rdx就是这两个参数。</p>
<p><img src="/2022/02/28/Boomlab/image-20220228181405909.png" alt="image-20220228181405909"></p>
<p>将0给eax，然后调用参数后将eax的值与1作比较，大于就不爆。然后将rsp+0x8的值，也就是rdx的值与7作比较，大于就跳转，小于就爆，回到上一步向下看，会将rdx的值给eax，然后跳到402470这个地址</p>
<p><img src="/2022/02/28/Boomlab/image-20220228182641784.png" alt="image-20220228182641784"></p>
<p>不知道这是个啥</p>
<p><img src="/2022/02/28/Boomlab/image-20220228182734910.png" alt="image-20220228182734910"></p>
<p>用IDA发现是到了switch语句。（其实是汇编语言的switch实现）</p>
<p>看后面的代码，都会跳到400fbe的位置，将eax的值与rsp+0xc的值作比较，相等则不爆。</p>
<p>这题答案不固定，根据第一个数不同，第二个数也会不同随机选取一组符合条件的即可。</p>
<h2 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase_4"></a>Phase_4</h2><p>代码</p>
<p><img src="/2022/02/28/Boomlab/image-20220228183854762.png" alt="image-20220228183854762"></p>
<p>前面几行跟上一个阶段一样，就是输入两个值作为参数。</p>
<p>再将eax的值与2作比较，不相等就爆。然后将0xe和rsp+0x8的值作比较，大于0xe就不跳，故此处需小于。</p>
<p>然后是三个赋值操作，再接着调用func4函数，然后验证eax的值，不为0就爆，接着rsp+0xc的值等于0，炸弹拆除。</p>
<p>func4:</p>
<p><img src="/2022/02/28/Boomlab/image-20220228200230163.png" alt="image-20220228200230163"></p>
<p>由上面的分析可知，此处要让eax的值为0。这玩意儿还挺复杂，自己调用自己，递归了。</p>
<p>大致逻辑：上面phase_4的edx，esi，edi作为func4的三个参数。将edx的值给eax，用eax的值减esi，然后保存在ecx，再将ecx的值逻辑右移31位（0x1f），再将eax的值与ecx的值相加，保存在eax，然后算数右移1位（需要注意与逻辑右移的区别。）然后是ecx&#x3D;rax+rsi*1，然后是ecx和edi比较，ecx较大就跳。400ff2处，edi的值小于ecx则跳转并结束该函数调用，否则将rcx+0x1的值给esi。从400fe6继续看，将rcx-0x1的值给edx，然后调用func4，然后eax+eax，然后结束调用。</p>
<p>上代码，帮助理解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span>&#123;</span><br><span class="line">    <span class="type">int</span> b = (a1 - a2) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="type">int</span> result = ((a1-a2) + b) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    b = result + a2;</span><br><span class="line">    <span class="keyword">if</span>(b == x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(b &lt; x) &#123;</span><br><span class="line">        result = fun(a1, b + <span class="number">1</span>, x);</span><br><span class="line">        <span class="keyword">return</span> result * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = fun(b - <span class="number">1</span>, a2, x);</span><br><span class="line">        <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处a1，a2，a3分别为0xe，0x0，rsp+0x8（输入的第一个值）</p>
<p>最后，什么时候返回0。我们将值代入发现，7是能返回0的一个界限，那么7，0可以作为一种答案。</p>
<p>看大佬们的解法才恍然大悟。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">0xe</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fun(<span class="number">0xe</span>,<span class="number">0</span>,i) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i) ;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>允许的答案由0 1 3 7，只需要简单调用一下函数就行，没想到。</p>
<h2 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase_5"></a>Phase_5</h2><p><img src="/2022/02/28/Boomlab/image-20220228210929709.png" alt="image-20220228210929709"></p>
<p>这1-7行刚开始是没看懂，后来看伪代码是v4 &#x3D; __readfsqword(0x28u)，这玩意儿。</p>
<p>eax存储了字符串长度，必须为6，否则就炸。然后再把0给eax，将输入保存在ecx，因为rax刚开始为0.</p>
<p>将cl的值（ecx的一个子寄存器）给rdx，然后获取edx的低四位。然后所得到的edx的值作为指针访问0x4024b0地址下的某一位（有点绕），一直到4010ac处的指令，可用代码表示为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0LL</span>; i != <span class="number">6</span>; ++i )</span><br><span class="line">    arry[i] = array_0x4024b0[*(a1 + i) &amp; <span class="number">0xF</span>];<span class="comment">//a1是eax的值，即字符串长度，6</span></span><br></pre></td></tr></table></figure>

<p>0x4024b0处</p>
<p><img src="/2022/02/28/Boomlab/image-20220228220413822.png" alt="image-20220228220413822"></p>
<p>将rsp+0x16的值化为0，也就是代表该字符串的末尾；0x40245e处：</p>
<p><img src="/2022/02/28/Boomlab/image-20220228215537273.png" alt="image-20220228215537273"></p>
<p>然后传入两个参数esi，rdi到strings_not_equal函数不相等就炸。</p>
<p>所以根据后续代码逻辑，我们需要在0x4024b0处的字符串中找到0x40245e处的下标。</p>
<p>分别是9 15 14 5 6 7，但是，这些都是答案的低四位</p>
<p>因为有取低四位这个步骤，这里给出C语言代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>[arry_4024b0[i]&amp;<span class="number">0xf</span>] = arry_0x40245e[i];</span><br></pre></td></tr></table></figure>

<p>借用一张图片，可以对着查询，任意选一组即可。</p>
<p><img src="/2022/02/28/Boomlab/63d9f2d3572c11dff05943a1652762d0f603c2ac.png" alt="63d9f2d3572c11dff05943a1652762d0f603c2ac"></p>
<h2 id="Phase-6"><a href="#Phase-6" class="headerlink" title="Phase_6"></a>Phase_6</h2><p>代码有点长，我们分部来看。</p>
<p>首先是将rsi作为参数传入read_six_numbers函数，然后又赋值，将eax的值减1后，与5作比较，小于等于5则不爆。然后将r12d的值加一（刚开始为0），与6比较，等于才跳，接着又有赋值操作，然后将eax与rbp+0作比较，相等就炸。</p>
<p><img src="/2022/02/28/Boomlab/image-20220301113532571.png" alt="image-20220301113532571"></p>
<p>接着来到401145处，ebx加一，再与5作比较，大于5就不跳。很明显一个循环。我们向下继续。</p>
<p>将r13的值加4，跳到刚刚的401114处，如此看来，r12d是循环次数，6次。从开始截至401151，是一个二重循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i=0; i&lt;6; i++)&#123;</span><br><span class="line">	if (arr[i] - 1 &gt; 5) bomb()</span><br><span class="line">		for (int j=i+1; j&lt;=5; j++) &#123;</span><br><span class="line">			if(arr[j] == arr[i]) bomb()</span><br><span class="line">			 &#125;</span><br><span class="line"> 		&#125;</span><br></pre></td></tr></table></figure>

<p>我们从401153处继续，向下还是一堆赋值操作，然后比较，rax和rsi不等就跳，向下看，0x0给esi，然后跳到401197.</p>
<p><img src="/2022/02/28/Boomlab/image-20220301120225795.png" alt="image-20220301120225795"></p>
<p>来到401197处</p>
<p><img src="/2022/02/28/Boomlab/image-20220301120702509.png" alt="image-20220301120702509"></p>
<p>首先是赋值，然后与1作比较，小于等于跳到401183否则跳到401176进行循环，然后通过401176的循环再步入401188的循环。</p>
<p>我们从4011ab向下看</p>
<p><img src="/2022/02/28/Boomlab/image-20220301121122327.png" alt="image-20220301121122327"></p>
<p>依然是一堆赋值，然后接上比较，相等就跳转。将rbx给rcx后，跳到4011bd处，进行循环，要循环8次，然后到4011d2处，接着又是一堆赋值，需要eax小于rbx的值，才跳转，否则炸。最后还有一个从4011df开始的循环（ebp-1不为0则跳转。）。其实是一个值的置换操作，不过是执行6次，按降序排列</p>
<p>需要注意一下4011a4处的命令</p>
<p><img src="/2022/02/28/Boomlab/image-20220301125119167.png" alt="image-20220301125119167"></p>
<p>看样子是个结构体（用IDA看就很明确）</p>
<p><img src="/2022/02/28/Boomlab/image-20220301124131818.png" alt="image-20220301124131818"></p>
<p><img src="/2022/02/28/Boomlab/image-20220301124149305.png" alt="image-20220301124149305"></p>
<p><img src="/2022/02/28/Boomlab/image-20220301124211115.png" alt="image-20220301124211115"></p>
<p><img src="/2022/02/28/Boomlab/image-20220301124227196.png" alt="image-20220301124227196"></p>
<p><img src="/2022/02/28/Boomlab/image-20220301124245570.png" alt="image-20220301124245570"></p>
<p><img src="/2022/02/28/Boomlab/image-20220301124303447.png" alt="image-20220301124303447"></p>
<p>所以以上逻辑大致为我们输入的序列被7减去后得到的序列，是一个向量，向量每个数字是node的序号，向量的顺序是node的链接顺序，也就是说向量的第一个序号对应的node会变成头节点</p>
<p>最后放上IDA的代码</p>
<p><img src="/2022/02/28/Boomlab/image-20220301122304972.png" alt="image-20220301122304972"></p>
<p><img src="/2022/02/28/Boomlab/image-20220301122335913.png" alt="image-20220301122335913"></p>
<p><img src="/2022/02/28/Boomlab/image-20220301122359866.png" alt="image-20220301122359866"></p>
<p>故，依照上述代码逻辑将6个node的值按降序排列，所得序号为3 4 5 6 1 2，但因为在这之前涉及x&#x3D;7-x这一操作</p>
<p>故正确答案应为4 3 2 1 6 5，至此扫雷。</p>
<h2 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h2><p><img src="/2022/02/28/Boomlab/image-20220301125404871.png" alt="image-20220301125404871"></p>
<p><img src="/2022/02/28/Boomlab/image-20220301130109136.png" alt="image-20220301130109136"></p>
<p>wairi,受不了了，直接放反编译出的代码</p>
<p><img src="/2022/02/28/Boomlab/image-20220301125918989.png" alt="image-20220301125918989"></p>
<p>func7</p>
<p><img src="/2022/02/28/Boomlab/image-20220301125942372.png" alt="image-20220301125942372"></p>
<p>和汇编代码对照看，第二个if是右移，第三个是左移</p>
<p>发现0x6030f0处的往后是个二叉树，</p>
<p><img src="/2022/02/28/Boomlab/image-20220301130237470.png" alt="image-20220301130237470"></p>
<p>再往后就是node了。</p>
<p>└─ 36<br>   ├─ 8<br>   │  ├─ 6<br>   │  │  ├─ left: 1<br>   │  │  └─ right: 7<br>   │  └─ 22<br>   │     ├─ left: 20<br>   │     └─ right: 35<br>   └─ 50<br>      ├─ 45<br>      │  ├─ left: 40<br>      │  └─ right: 47<br>      └─ 107<br>         ├─ left: 99<br>         └─ right: 1001</p>
<p>我们需要找的数，是最后返回2的，那么，最后一次就返回0，再上一次返回2 * rax + 1，第一次返回2 * rax </p>
<p>那么两个值可以，20或22.</p>
<p>至此，扫雷完毕。</p>
<h2 id="不算小结的小结"><a href="#不算小结的小结" class="headerlink" title="不算小结的小结"></a>不算小结的小结</h2><p>汇编看起来确实麻烦，做最后两个的时候都是结合C语言代码来搞得，对汇编还不是很熟悉。</p>
<p>这个实验如果用IDA当逆向题做的话，难度会降低很多。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2298233831.github.io/2022/01/06/CSAPP-DATAlab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yu4n">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Blog of Yu4n">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/06/CSAPP-DATAlab/" class="post-title-link" itemprop="url">CSAPP DATAlab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-06 16:02:49" itemprop="dateCreated datePublished" datetime="2022-01-06T16:02:49+08:00">2022-01-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-31 19:15:21" itemprop="dateModified" datetime="2022-05-31T19:15:21+08:00">2022-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="bitXor-x-y-用‘-amp-’和‘-’完成异或操作"><a href="#bitXor-x-y-用‘-amp-’和‘-’完成异或操作" class="headerlink" title="bitXor(x,y)用‘&amp;’和‘~’完成异或操作"></a>bitXor(x,y)用‘&amp;’和‘~’完成异或操作</h1><p>在此之前，我们先了解一下这三个运算符的运算规则</p>
<p>设A&#x3D;60，B&#x3D;13；</p>
<p>则A &#x3D; 0011 1100；B &#x3D; 0000 1101。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">“与”--‘&amp;’：</span><br><span class="line">0&amp;0=0;   </span><br><span class="line">0&amp;1=0;    </span><br><span class="line">1&amp;0=0;     </span><br><span class="line">1&amp;1=1;A&amp;B=0000 1100</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“取反”--‘~’：</span><br><span class="line">对形式取反</span><br><span class="line">~A = 1100 0011 = -61。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">“异或”--‘^’：</span><br><span class="line">0^0=0;   </span><br><span class="line">0^1=1;   </span><br><span class="line">1^0=1;  </span><br><span class="line">1^1=0;</span><br><span class="line">(A ^ B) 将得到 49，即为 0011 0001</span><br></pre></td></tr></table></figure>

<p>可以看到，&amp;和^的区别在于，除两数同时为0时，结果相反。那么我们分而治之，设置两种情况，以上面的A,B为例。</p>
<p>第一种–只考虑不是两个0进行运算的时候：两数直接进行&amp;运算然后取反，得1111 0011；</p>
<p>第二种–只考虑是两个0进行运算的时候：这次我们的目的是在其他数（即上面那个数从左往右的第3、4、5、6，8位）经过运算且发生变化后保持0和0进行运算后结果依然为0，才能让两个最终运算结果在最后&amp;时得到与^相同的数。这里绕个弯，先将A,B各自取反，进行&amp;运算后，再将结果取反。可以发现达到了开始时的目的</p>
<p>最后，将两情况的结果进行与运算，得到答案。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ~(~x&amp;~y)&amp;~(x&amp;y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借用大佬的思路如下：（比我清晰很多，一语即中。）</p>
<p>所谓异或就是当参与运算的两个二进制数不同时结果才为1，其他情况为0。<code>C</code> 语言中的位操作对基本类型变量进行运算就是对类型中的每一位进行位操作。所以结果可以使用“非”和“与”计算<strong>不是同时为0情况和不是同时为1的情况进行位与</strong>，即<code>~(~x&amp;~y)&amp;~(x&amp;y)</code> 。</p>
<h1 id="tmin-最小二进制补码整数型"><a href="#tmin-最小二进制补码整数型" class="headerlink" title="tmin()最小二进制补码整数型"></a>tmin()最小二进制补码整数型</h1><p>因为整数int型位32位（一般情况下，此处不讨论16位），而最小的补码只需要是第一位为1（1开头表示负数），后面的全是0即可，所以只需要将1左移31位即可（因为机器从0开始读。）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="isTmax-x-判断当X为最大整型二进制数为真，否则为假"><a href="#isTmax-x-判断当X为最大整型二进制数为真，否则为假" class="headerlink" title="isTmax(x)判断当X为最大整型二进制数为真，否则为假"></a>isTmax(x)判断当X为最大整型二进制数为真，否则为假</h1><p>此处先说明一下最大二进制整数，其实是0x7fffffff(二进制整数首位是 0，其余都是1，f代表1111，32位)</p>
<p>F的二进制码为 1111<br>7的二进制码为 0111；0xffffffff为-1；但最小值是0x80000000</p>
<p>上文说了开头为1表示是负数，为0则为正数。</p>
<p>对最大整型数有以下特征：</p>
<p>Tmax+1 &#x3D; Tmin&#x3D;~Tmax</p>
<p>故代码需要让唯一情况为0x7fffffff,并排除0xffffffff。</p>
<p>0x7fffffff+1&#x3D;0x80000000</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(x+(x+<span class="number">1</span>))|!(x+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="判断所有奇数位是否均为1"><a href="#判断所有奇数位是否均为1" class="headerlink" title="判断所有奇数位是否均为1"></a>判断所有奇数位是否均为1</h1><p>这需要用到0xAAAAAAAA来进行判断。</p>
<p><img src="/2022/01/06/CSAPP-DATAlab/image-20220204145219988.png" alt="image-20220204145219988"></p>
<p>先构造该数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0xAA</span>+(<span class="number">0xAA</span>&lt;&lt;<span class="number">8</span>);#左移<span class="number">8</span>位，构造<span class="number">0xAAAA</span></span><br><span class="line">    i += i&lt;&lt;<span class="number">16</span>;#构造<span class="number">0xAAAAAAAA</span></span><br><span class="line">    <span class="keyword">return</span> !((i&amp;x)^i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="不用-，求-x的值"><a href="#不用-，求-x的值" class="headerlink" title="不用-，求-x的值"></a>不用-，求-x的值</h1><p>这个很简单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="判断是否是0-9的ASCII码值"><a href="#判断是否是0-9的ASCII码值" class="headerlink" title="判断是否是0~9的ASCII码值"></a>判断是否是0~9的ASCII码值</h1><p>首先确定范围是0x30~0x39。</p>
<p>从二进制原码上下手会比较好理解。0x30~0x39，只用考虑低四位。(9为0x1001)</p>
<p>但还有一个问题0x30<del>0x39的第5</del>8位为0011.</p>
<p>所以还得先判断第5~8位是否为0011，再来判断第四位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isAsciiiDigit</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> z=<span class="number">0xf</span>,y=<span class="number">3</span>,p=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">return</span> !(((x&gt;&gt;<span class="number">4</span>)^y)|(x&amp;z)+p)&gt;&gt;<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>((x&gt;&gt;4)^y)用于判断第5<del>8位是否为0011，先将5</del>8位变为1~4位，再异或3，返回0则对。</p>
<p>(x&amp;z)+p)&gt;&gt;4用于判断1~4位：首先我们知道，十六进制数位0123456789ABCDEF，以9来考虑，加上6后是有进位的，故上限可加6然后再左移看进位与否判断，下限自然不用了，毕竟开头的是0不是1就行。</p>
<h1 id="使用位级运算实现C语言中的-x-y-z三目运算符。"><a href="#使用位级运算实现C语言中的-x-y-z三目运算符。" class="headerlink" title="使用位级运算实现C语言中的 x?y:z三目运算符。"></a>使用位级运算实现C语言中的 x?y:z三目运算符。</h1><p>首先了解一下何为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6/6434591">三目运算符</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x&gt;&gt;<span class="number">31</span>|((~x+<span class="number">1</span>)&gt;&gt;<span class="number">31</span>))&amp;y)|(~x&gt;&gt;<span class="number">31</span>|(~x+<span class="number">1</span>)&gt;&gt;<span class="number">31</span>))&amp;z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一种特殊情况：当条件为假的时候，而当结果1为零时，返回结果2。</p>
<p>故总共有三种情况。</p>
<p>条件用(x&gt;&gt;31|((~x+1)&gt;&gt;31))判断。后续根据相应结果做最后运算。</p>
<h1 id="使用位级运算符实现-lt-x3D"><a href="#使用位级运算符实现-lt-x3D" class="headerlink" title="使用位级运算符实现&lt;&#x3D;"></a>使用位级运算符实现&lt;&#x3D;</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !!((x&gt;&gt;<span class="number">31</span>)&amp;(~y&gt;&gt;<span class="number">31</span>))|(!!((x+(~y+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>)&amp;~((~x&gt;&gt;<span class="number">31</span>)&amp;y&gt;&gt;<span class="number">31</span>))|!(x+(~y+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们并不知道两个数正负，所以先对正负，也就是符号位进行判断（四种情况）：都为正或负，一正一负。</p>
<p>那么挨个实现即可，难度不大。(&gt;&gt;31是为了对符号位进行比较。)</p>
<p>(一个小技巧：!!x可以把非零数变为1，0变为0。)</p>
<h1 id="计算-x却不用-符号"><a href="#计算-x却不用-符号" class="headerlink" title="计算!x却不用!符号"></a>计算!x却不用!符号</h1><p>！：称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</p>
<p>简而言之，使结果呈相反状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ~(x&gt;&gt;<span class="number">31</span>)&amp;(((~x+<span class="number">1</span>)&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以从符号位上下手，布尔代数只有0和1。符号位也是只有0和1。</p>
<p>将其本身的符号位与上其相反数的符号位加1（若ｘ为0，则加1后为0反之为1.）最后取反。</p>
<h1 id="计算一个数用补码表示最少需要几位"><a href="#计算一个数用补码表示最少需要几位" class="headerlink" title="计算一个数用补码表示最少需要几位"></a>计算一个数用补码表示最少需要几位</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> b16,b8,b4,b2,b1,b0;</span><br><span class="line">    <span class="type">int</span> sign=x&gt;&gt;<span class="number">31</span>,ret=<span class="number">0</span>;</span><br><span class="line">    x = (sign&amp;~x)|(~sign&amp;x);</span><br><span class="line">    ret=<span class="number">1</span>+!!x;</span><br><span class="line">    b16=!!(x&gt;&gt;<span class="number">16</span>)&lt;&lt;<span class="number">4</span>;</span><br><span class="line">    x=x&gt;&gt;<span class="number">16</span>;</span><br><span class="line">    b8=!!(x&gt;&gt;<span class="number">8</span>)&lt;&lt;<span class="number">3</span>;</span><br><span class="line">    x=x&gt;&gt;b8;</span><br><span class="line">    b4=!!(x&gt;&gt;<span class="number">4</span>)&lt;&lt;<span class="number">2</span>;</span><br><span class="line">    x=x&gt;&gt;b4;</span><br><span class="line">    b2=!!(x&gt;&gt;<span class="number">2</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    x=x&gt;&gt;<span class="number">2</span>;</span><br><span class="line">    b1=!!(x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> b16+b8+b4+b2+b1+ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个题就像一排座位，判断上面有多少是坐了人的。（但是不能直接看见）</p>
<p>所以先将整体一分为二，拆为高低16位，先判断高16位的值是否为0，不是的话将高16位提取出，再一分为二，高8位，低8位。同样的方法判断；若高16位为0，则采用如上相同方法判断。</p>
<p>当然，还得先看符号位是啥，前面说过，!!x可以将非零数变为1，0变为0。</p>
<h1 id="求浮点数-u-f-2"><a href="#求浮点数-u-f-2" class="headerlink" title="求浮点数(u)f*2"></a>求浮点数(u)f*2</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((uf&gt;=<span class="number">0x7f800000</span> &amp;&amp; uf&lt;=<span class="number">0x7fffffff</span>)||(uf&gt;=<span class="number">0xff800000</span> &amp;&amp; uf&lt;=<span class="number">0xffffffff</span>) || uf==<span class="number">0</span> || uf==<span class="number">0x80000000</span>)</span><br><span class="line">        <span class="keyword">return</span> uf;  <span class="comment">//当uf=NAN或无穷或0的时候，返回它本身</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(uf&gt;<span class="number">0x80000000</span> &amp;&amp; uf&lt;=<span class="number">0x807fffff</span>)</span><br><span class="line">        <span class="keyword">return</span> ((uf&lt;&lt;<span class="number">1</span>)+<span class="number">0x80000000</span>);  <span class="comment">// uf为负的非规格化数  </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(uf&gt;<span class="number">0</span> &amp;&amp; uf&lt;=<span class="number">0x007fffff</span>)</span><br><span class="line">        <span class="keyword">return</span> uf&lt;&lt;<span class="number">1</span>;  <span class="comment">//uf为正的非规格化数</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (uf+(<span class="number">1</span>&lt;&lt;<span class="number">23</span>));  <span class="comment">// uf为规格化数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于浮点数，有必要知道阶<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%98%B6%E7%A0%81/7798285">阶码</a>,<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%A7%84%E6%A0%BC%E5%8C%96/6971871">规格化</a></p>
<p>还是得先排除NaN，无穷大&#x2F;小，0这些情况。所以当浮点数为无穷，0或NAN时，返回本身，阶码全为1</p>
<p>再就是规格化数：阶码加一和非规格化数（非规格化数有正负之分，且阶码全为0：正数左移一位，负数补最高位一个1）。</p>
<h1 id="将浮点型转换为整型"><a href="#将浮点型转换为整型" class="headerlink" title="将浮点型转换为整型"></a>将浮点型转换为整型</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">int</span> s_    = uf&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> exp_  = ((uf&amp;<span class="number">0x7f800000</span>)&gt;&gt;<span class="number">23</span>)<span class="number">-127</span>;</span><br><span class="line">  <span class="type">int</span> frac_ = (uf&amp;<span class="number">0x007fffff</span>)|<span class="number">0x00800000</span>;</span><br><span class="line">  <span class="keyword">if</span>(!(uf&amp;<span class="number">0x7fffffff</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(exp_ &gt; <span class="number">31</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">  <span class="keyword">if</span>(exp_ &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(exp_ &gt; <span class="number">23</span>) frac_ &lt;&lt;= (exp_<span class="number">-23</span>);</span><br><span class="line">  <span class="keyword">else</span> frac_ &gt;&gt;= (<span class="number">23</span>-exp_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!((frac_&gt;&gt;<span class="number">31</span>)^s_)) <span class="keyword">return</span> frac_;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(frac_&gt;&gt;<span class="number">31</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> ~frac_+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先考虑特殊情况：如果原浮点值为0则返回0；如果真实指数大于31（frac部分是大于等于1的，1&lt;&lt;31位会覆盖符号位），返回规定的溢出值<strong>0x80000000u**；如果 <img src="https://www.zhihu.com/equation?tex=exp%3C0" alt="[公式]"> （1右移x位,x&gt;0，结果为0）则返回0。剩下的情况：首先把小数部分（23位）转化为整数（和23比较），然后判断是否溢出：如果和原符号相同则直接返回，否则如果结果为负（原来为正）则溢出返回越界指定值</strong>0x80000000u**，否则原来为负，结果为正，则需要返回其补码（相反数)。</p>
<h1 id="求2的x次方"><a href="#求2的x次方" class="headerlink" title="求2的x次方"></a>求2的x次方</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(x&gt;=<span class="number">0x80000000</span> &amp;&amp; x&lt;<span class="number">0xffffff6a</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;            <span class="comment">//  表示的数小于32位float表示的最小值</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;=<span class="number">0xffffff6a</span> &amp;&amp; x&lt;=<span class="number">0xffffff81</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;(<span class="number">149</span>+x);   <span class="comment">//  表示的数是非规格化数</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;=<span class="number">0x00000080</span> &amp;&amp; x&lt;<span class="number">0x80000000</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0x7f800000</span>;   <span class="comment">//  表示的数大于32位浮点数表示的最大值</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;   <span class="comment">//  规格化情况</span></span><br><span class="line">          <span class="type">unsigned</span> y=x+<span class="number">127</span>;</span><br><span class="line">          <span class="keyword">return</span> y&lt;&lt;<span class="number">23</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先分析什么时候返回0，也就是当小于float最小表示的数的时候返回0。因为2^x必然是大于0的，float表达的最小数就是0x1，此时为2的-126次方乘以2的-23次方，等于2的-149次方，所以第一种情况就是x大于-149，则返回0。<br>  然后再分析什么时候返回正无穷，float表示的最大值是0x7f7fffff，即当x大于等于128（阶码全为1）的时候表示无穷，返回正无穷。<br>  然后分析，2^x能表示当float阶码为0，尾数只有一位为1的情况和阶码为0x1，尾数为0的情况即-149&lt;&#x3D;x&lt;&#x3D;-126。这个时候的float的表示应该是除了尾数有一位为1，其他位都是0。可以计算出尾数为1的那一位距离尾数最低位的位数m，然后将1&lt;&lt;m即可。这里的m应该用“23-（-x-126）”即m&#x3D;149+x。所以是1&lt;&lt;(149+x)。<br>  然后就是规格化数的一种情况，这种情况最简单，就是阶码位加一就可以了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2298233831.github.io/2021/12/26/DLL%E6%B3%A8%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yu4n">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Blog of Yu4n">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/26/DLL%E6%B3%A8%E5%85%A5/" class="post-title-link" itemprop="url">DLL注入</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-26 18:47:54" itemprop="dateCreated datePublished" datetime="2021-12-26T18:47:54+08:00">2021-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 22:12:50" itemprop="dateModified" datetime="2022-01-05T22:12:50+08:00">2022-01-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Hook钩子"><a href="#Hook钩子" class="headerlink" title="Hook钩子"></a>Hook钩子</h1><p>首先是一个比较简单的DLL，可以钩取用户从键盘上输入的信息。</p>
<p>这一节的主要目的应该还是后面调试应用程序那一部分。</p>
<p>那着重说一下调试部分：</p>
<p>​    本次调试重点在于，能够钩取键盘输入的DLL是如何载入到程序当中的。按书中操作，在调试设置中勾选当DLL载入时暂停的选项。通过主函数体可知，主函数体中存在LoadLibrary这一能将DLL文件导入到应用程序中的关键函数。（该函数的作用：将指定的模块加载到调用进程的地址空间中。指定的模块可能会导致其他模块被加载。）</p>
<h1 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h1><p>首先是注入的三个方法：</p>
<ol>
<li>创建远程线程</li>
<li>使用注册表</li>
<li>消息钩取</li>
</ol>
<h2 id="创建远程线程注入"><a href="#创建远程线程注入" class="headerlink" title="创建远程线程注入"></a>创建远程线程注入</h2><p>涉及关键应用InjectDLL.exe,该应用程序的源码在书中已有详细的逐行介绍，此处不再赘述。（这几章的关键都在实现对应功能的程序的代码，理解其代码是重点和难点，实际操作反而容易。）</p>
<p>说一下句柄的意义—-句柄实际是一个指针，他指向一块包含具体信息数据的内存，可以当做索引 ，所以进程句柄是当你要访问该进程时取得的，使用完毕必须释放。</p>
<p>总的过程就是：</p>
<p>先将要注入的DLL路径写入内存（在此之前会先调用函数分配缓冲区，大小为DLL文件路径字符串的长度）—然后获得加载DLL函数的地址—在要被注入DLL的进程中创建远程线程—调用加载DLL文件的函数来加载（注入）DLL</p>
<p>有一处值得注意：</p>
<p><img src="/2021/12/26/DLL%E6%B3%A8%E5%85%A5/image-20220105162354191.png" alt="image-20220105162354191"></p>
<h2 id="使用注册表注入"><a href="#使用注册表注入" class="headerlink" title="使用注册表注入"></a>使用注册表注入</h2><p><img src="/2021/12/26/DLL%E6%B3%A8%E5%85%A5/image-20220105162917205.png" alt="image-20220105162917205"></p>
<p>修改AppInit_DLLs表项的值，将其值改为待注入DLL文件的路径（最后以该文件命结尾的完整路径），再将LoadAppInit_DLLs的值改为1.最后重启系统，及完成该修改。</p>
<p>消息钩取暂不做讨论。</p>
<h1 id="DLL卸载"><a href="#DLL卸载" class="headerlink" title="DLL卸载"></a>DLL卸载</h1><p>还是一样，先读懂相应程序的源代码。其实跟注入差不多的，只是是卸载罢了。亲自看一遍会有更深的印象。</p>
<p>另外，PE文件直接导入的DLL文件是无法被卸载的，该方法仅适用于自己强行注入的DLL文件。 </p>
<h1 id="通过修改PE加载DLL"><a href="#通过修改PE加载DLL" class="headerlink" title="通过修改PE加载DLL"></a>通过修改PE加载DLL</h1><p>先贴一篇关于<a target="_blank" rel="noopener" href="https://blog.csdn.net/wangshubo1989/article/details/53203718">HWND,HANDLE,HMODLE,HINSTANCE的区别</a>的博客，有个基础了解即可。</p>
<p>在这一章停了一段时间，说一下我遇到的问题。</p>
<p>首先就是IID整体大小，14为IID结构体大小，5为IID结构体个数</p>
<p><img src="/2021/12/26/DLL%E6%B3%A8%E5%85%A5/image-20220105182929724.png" alt="image-20220105182929724"><img src="/2021/12/26/DLL%E6%B3%A8%E5%85%A5/image-20220105183003195.png" alt="image-20220105183003195"></p>
<p>此处因为union结构体的缘故，故只有5个IID结构体。</p>
<p>简单说一下union结构体：(union)共用体占用的内存应足够存储共用体中最大的成员。</p>
<p>然后注意在创建新IDT时是设计了RVA to RAW的转换的，此处也就就不再赘述了。</p>
<p>另外，移动到可用的空白区域即可，不是非要移动到RVA为8C80处。</p>
<p><img src="/2021/12/26/DLL%E6%B3%A8%E5%85%A5/image-20220105185215395.png" alt="image-20220105185215395"></p>
<p>然后一个点，bit OR是位操作  (   |   这个符号)，虽然说结果跟异或(bit XOR)一样。4|8&#x3D;&#x3D;12&#x3D;&#x3D;4^8,4|0&#x3D;&#x3D;4&#x3D;&#x3D;4^0。</p>
<h1 id="代码注入DLL"><a href="#代码注入DLL" class="headerlink" title="代码注入DLL"></a>代码注入DLL</h1><p>本章关键在于读懂InjectCode()函数的代码。<br>其实使用的关键API就那么几个</p>
<p>OpenProcess()<br>VirtualAllocEx()相对的有VirtualFreeEx()<br>WriteProcessMemory()相对的有ReadProcessMemory()<br>CreateRemoteThread()</p>
<p>多加理解，对着敲一遍也不错。</p>
<h1 id="使用汇编语言编写注入代码"><a href="#使用汇编语言编写注入代码" class="headerlink" title="使用汇编语言编写注入代码"></a>使用汇编语言编写注入代码</h1><p>前面编写汇编语言部分可以看看，能大致理解就行（本章后面是由逐行解析的）</p>
<p>关键在于后面的CodeInjection2.cpp的代码。</p>
<p>其实看看代码内容，核心的API确实就上面那几个。不过是加入了要注入的代码的十六进制数据。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>纸上得来终觉浅，绝知此事要躬行。还是要多动手实践，这部分很注重实操。如果看不太懂，不妨试着结合网络写笔记，写的过程中逐一突破。</p>
<p><img src="/2021/12/26/DLL%E6%B3%A8%E5%85%A5/image-20220105220107191.png" alt="image-20220105220107191"></p>
<p>最后再上一碗鸡汤，多是一件美事。</p>
<p><img src="/2021/12/26/DLL%E6%B3%A8%E5%85%A5/image-20220105220319771.png" alt="image-20220105220319771"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2298233831.github.io/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yu4n">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Blog of Yu4n">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">逆向工程核心原理PE文件格式部分总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-24 10:27:24" itemprop="dateCreated datePublished" datetime="2021-12-24T10:27:24+08:00">2021-12-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-25 15:41:17" itemprop="dateModified" datetime="2021-12-25T15:41:17+08:00">2021-12-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UPX部分"><a href="#UPX部分" class="headerlink" title="UPX部分"></a>UPX部分</h1><p>众所周知，UPX是一种较为常见的压缩壳。（除压缩壳外，还有加密壳）</p>
<p>先对壳做个基本的了解：壳的初始作用是保护软件，但后来发展的方向不一就出现了各种各样的壳，大致有压缩壳、加密壳、VM 壳的分类。压缩壳故名思意，主要作用是用于压缩方面，可以有效的减小软件的大小；加密壳，其主要作用是保护软件；VM 壳是一种很特殊的壳，它利用了虚拟机技术，可以很有效的保护指定地址代码，但很大的牺牲了效率，所以一般只在关键代码处使用。（其实就是隐藏函数的OEP–主要入口点）</p>
<h2 id="压缩和压缩方式"><a href="#压缩和压缩方式" class="headerlink" title="压缩和压缩方式"></a>压缩和压缩方式</h2><ol>
<li><p>压缩又分为无损压缩和有损压缩。</p>
<p>两种压缩都是为了能节省一定的空间，只是无损不会使数据不完整(如各种压缩包)；而有损有时会通过压缩文件（数据）损失一定的信息，来提高压缩率（如mp3、mp4和jpg文件，这也是为什么前两个有音质和画质之分的根源所在吧）。</p>
</li>
<li><p>压缩方式大体分为两种：普通压缩和运行时压缩。一张图说明二者区别</p>
</li>
</ol>
<p><img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224113639435.png" alt="image-20211224113639435"></p>
<p>运行时压缩（也叫PE压缩器）是针对PE文件的。PE文件内部含有解压缩代码，运行瞬间于内存中解压然后执行。</p>
<p>上文说过，压缩可以节约内存空间，还有一点，能够隐藏PE文件的内部代码和资源。</p>
<ol start="3">
<li>既然压缩的目的是为了防止内部代码资源泄露，那么为了对PE文件提供更强的保护，PE保护器就存在了。</li>
</ol>
<p><img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224114154673.png" alt="image-20211224114154673"></p>
<ol start="4">
<li>压缩文件和正常文件的PE结构的区别(感觉这一块书上已经将的很清楚了，就放原图吧。)<br> <img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224114504354.png" alt="image-20211224114504354"></li>
</ol>
<p>  <img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224120500126.png" alt="image-20211224120500126"></p>
<p><img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224120527464.png" alt="image-20211224120527464"></p>
<h2 id="脱UPX壳"><a href="#脱UPX壳" class="headerlink" title="脱UPX壳"></a>脱UPX壳</h2><p>32位的就没啥说的了拖进OD找到PUSH ad和POP ad就行了或者能用ESP定律就更好</p>
<p>64位就需要单步跟踪了，具体情况具体分析（推介X64dbg）。</p>
<h1 id="关于重定位"><a href="#关于重定位" class="headerlink" title="关于重定位"></a>关于重定位</h1><p>前面浅谈PE文件的时候，简单说过重定位。</p>
<p>这里再贴一下吧</p>
<p><img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224121526295.png" alt="image-20211224121526295"></p>
<p>本次我们注重关注在重定位的原理。</p>
<h2 id="PE文件重定位的原理"><a href="#PE文件重定位的原理" class="headerlink" title="PE文件重定位的原理"></a>PE文件重定位的原理</h2><p><img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224122210645.png" alt="image-20211224122210645"></p>
<p>查值通过基址重定位表完成，基址定位表地址如下：</p>
<p><img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224123046202.png" alt="image-20211224123046202"></p>
<p>基址定位表是IMAGE_BASE_RELOCATION结构体数组</p>
<p>该结构体含有两个成员：1. 基准地址virtualaddrss—RVA值（DWORD型）；2.SizeOfBlock—重定位块的大小（DWORD型）还有一个被注释的Typeoffset—表示该结构体下会出现WORD型的数组，该数组元素的值就是硬编码在程序中的地址偏移。</p>
<p>此处易将VA和RVA混淆，贴一个。</p>
<p><img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224152619953.png" alt="image-20211224152619953"></p>
<p>通过找到基址重定位表的RVA的值，我们在.reloc节区可以发现</p>
<p><img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224151613796.png" alt="image-20211224151613796"></p>
<p><img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224151859721.png" alt="image-20211224151859721"></p>
<p>该重定位节区在2AE00开始，那根据其结构体成员可知，RVA的值位1000，重定位块的大小为150（都是小端序标识法。）</p>
<p><img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224152136922.png" alt="image-20211224152136922"></p>
<p>我们已经知道Typeoffset（它的低12位是真正的基于VirtualSize位置的偏移。）是WORD型（两字节，16位）的，其由4位的Type和12位的offset合成的。</p>
<p>比如第一个3420，其Type为3，offset为420。</p>
<p>程序中硬编码地址的偏移用如下等式换算：</p>
<p>VirtualSize+Offsize&#x3D;RVA（该等式中，VirtualSize和RVA易混淆，见上文所贴的图。）</p>
<p><img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224155355494.png" alt="image-20211224155355494"></p>
<p>可以看到图片下方的ds里有IAT的地址VA，C010C4（不同设备运行，值不一样。）</p>
<p>使用上述偏移值可以查找硬编码地址值，将该值减去ImageBase,再加上实际加载地址，即可得到VA，完成重定位。</p>
<p>对于程序内硬编码的地址，PE装载器都做如上的处理，根据实际加载的内存地址修正后，将得到的值覆盖到同一位置上。对一个IMAGE_BASE_RELOCATION结构体的所有TypeOffset都做如上处理，且对RVA 1000～2000地址区域对应的所有硬编码地址都要进行PE重定位处理。如果TypeOffset值为0，说明一个IMAGE_BASE_RELOCATION结构体结束。至此，完成重定位流程。</p>
<h1 id="删除重定位节区-reloc"><a href="#删除重定位节区-reloc" class="headerlink" title="删除重定位节区.reloc"></a>删除重定位节区.reloc</h1><p>由于该节区对程序正常运行没有影响，且删除后文件大小将缩减。故试着删除：</p>
<p><img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224161108321.png" alt="image-20211224161108321"></p>
<p>可以看到，该节区区域为270-297，用00填充该区域；接着删除该节区，根据该节区的其起始偏移位置C000，一直到末尾，删除即可（因为.reloc为最后一个节区，所以直接到拉到文件末尾进行删除）；然后修改节区数，该文件原有5个节区，现在删了一个，将其改为4个，在文件头里面修改number os sections</p>
<p><img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224161900975.png" alt="image-20211224161900975"></p>
<p>下图为已经更改过的<img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224161923290.png" alt="image-20211224161923290"></p>
<p>最后就是修改可选头的文件（映像）大小，size of image。</p>
<p>同样的的方法</p>
<p><img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224162116107.png" alt="image-20211224162116107"></p>
<p>该重定位节区的大小为E40</p>
<p>这里还需要用到如下知识。（选自加密与解密第四版）</p>
<p><img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224162435728.png" alt="image-20211224162435728"></p>
<p>在可选头中，我们找到了两种对齐值</p>
<p><img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224162757991.png" alt="image-20211224162757991"></p>
<p>故，E40需对齐到1000.再用原本的size of image将其减去，则为10000，做出修改。</p>
<p>至此，重定位节区算是删除完成了。</p>
<h1 id="UPack-PE文件头分析及查找OEP"><a href="#UPack-PE文件头分析及查找OEP" class="headerlink" title="UPack PE文件头分析及查找OEP"></a>UPack PE文件头分析及查找OEP</h1><p>感觉没啥好说的，对着书看吧…</p>
<h1 id="内嵌补丁-内嵌代码补丁"><a href="#内嵌补丁-内嵌代码补丁" class="headerlink" title="内嵌补丁(内嵌代码补丁)"></a>内嵌补丁(内嵌代码补丁)</h1><p>先上一张概念图:</p>
<p><img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224164128856.png" alt="image-20211224164128856"></p>
<p>整个过程中,值得注意的点:</p>
<ol>
<li>程序运行的逻辑</li>
<li>代码整体结构(借用一下书上的图)<img src="/2021/12/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/image-20211224164351755.png" alt="image-20211224164351755"></li>
<li>补丁代码设置的位置<ul>
<li>设置到文件的空白区域</li>
<li>扩展最后节区后设置</li>
<li>添加新节区后设置</li>
</ul>
</li>
<li>异或操作和加密区域的查找—(涉及RVA to RAW的转化。)</li>
</ol>
<p>对该练习有疑惑可以参考一下文章：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/SKI_12/article/details/80670045">内嵌补丁练习_Mi1k7ea-CSDN博客</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>注重实操。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2298233831.github.io/2021/12/21/normal%E9%A2%98%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E9%A2%98%E6%89%80%E5%AD%A6%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yu4n">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Blog of Yu4n">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/21/normal%E9%A2%98%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E9%A2%98%E6%89%80%E5%AD%A6%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95/" class="post-title-link" itemprop="url">normal题的两个安卓逆向题所学及其拓展</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-21 21:30:16" itemprop="dateCreated datePublished" datetime="2021-12-21T21:30:16+08:00">2021-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-25 17:30:04" itemprop="dateModified" datetime="2021-12-25T17:30:04+08:00">2021-12-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C语言中函数调用约定"><a href="#C语言中函数调用约定" class="headerlink" title="C语言中函数调用约定"></a>C语言中函数调用约定</h1><p>首先定义如下函数 int function(int a, int,b)</p>
<p>我们都知道，机器是无法识别代码的，它只认识0，1。我们只需要通过another_number &#x3D; function(a,b)就能够条用该函数。而在cpu中，计算机并不知道调用该函数需要传递几个、什么类型的参数。为了完成调用这一过程，计算机提供了“栈”这种数据结构来支持传递参数。</p>
<p>（栈的结构等相关内容不再赘述）</p>
<p>函数调用时，调用者依次把参数压栈，然后调用函数，函数被调用以后，在栈中取得数据，并进行计算。函数计算结束以后，或者调用者、或者函数本身修改栈，使栈恢复原装（初始状态）。</p>
<p>此处面临两个问题：</p>
<ul>
<li><p>参数多于1个时，应该按什么顺序把参数压入栈？</p>
</li>
<li><p>函数调用后，由谁来把栈恢复原装？</p>
</li>
</ul>
<p>在高级语言中，通过函数调用约定来说明这两个问题。常见的调用约定有：</p>
<ul>
<li>stdcall</li>
<li>cdecl</li>
<li>fastcall</li>
<li>thiscall</li>
<li>naked call</li>
</ul>
<h2 id="stdcall-很多时候被称为pascal调用约定"><a href="#stdcall-很多时候被称为pascal调用约定" class="headerlink" title="stdcall(很多时候被称为pascal调用约定)"></a>stdcall(很多时候被称为pascal调用约定)</h2><p>(Win32 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/API%E5%87%BD%E6%95%B0/9554990">API函数</a>绝大部分都是采用_stdcall调用约定的。<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/WINAPI/3256750">WINAPI</a>其实也只是_stdcall的一个别名而已。)</p>
<p>stdcall的调用约定意味着：1. 参数从右向左压入栈；2. 函数自身修改栈；3. 函数名自动加”_”，后面紧跟一个”@”符号，其后紧跟着参数的尺寸（字节数）。</p>
<p>在编译时，这个函数的名字按照如上所述，会被翻译成_function@8</p>
<p>函数调用过程的汇编语言如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push b      第二个参数入栈</span><br><span class="line">push a      第一个参数入栈</span><br><span class="line">call function  调用参数，注意此时自动把cs:eip入栈</span><br></pre></td></tr></table></figure>

<p>而对于函数自身，则可以翻译为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push ebp     保存ebp寄存器，该寄存器将用来保存栈的栈顶指针，可以在函数退出时恢复</span><br><span class="line">mov ebp,esp  保存栈指针</span><br><span class="line">mov  eax,[ebp + 8H]  栈中ebp指向位置之前依次保存有ebp,cs:eip,a,b,ebp +8指向a</span><br><span class="line">add eax,[ebp + 0CH]  栈中ebp + 12处保存了b</span><br><span class="line">mov  esp,ebp         恢复esp</span><br><span class="line">pop ebp</span><br><span class="line">ret 8</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/21/normal%E9%A2%98%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E9%A2%98%E6%89%80%E5%AD%A6%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95/%E6%A0%88%E5%B8%A7.jpg" alt="栈帧"></p>
<p>（贴一张栈帧帮助理解）</p>
<p>函数结束后，ret 8表示清理8个字节的栈，函数自己恢复了栈。</p>
<h2 id="cdecl调用约定-C调用约定"><a href="#cdecl调用约定-C调用约定" class="headerlink" title="cdecl调用约定(C调用约定)"></a>cdecl调用约定(C调用约定)</h2><p>该约定为C语言默认的调用约定：<u>所有参数<strong>从右到左</strong>依次入栈，这些参数由调用者清除，称为手动清栈。</u>命名规则为在函数名前自动加“_”.</p>
<p>被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (__cdecl)function(int a,int b)   //加不加_cdecl都一样，只是有没有明确指出的区别</span><br></pre></td></tr></table></figure>

<p>因为是手动清栈，所以在最后的ret便不会清理，故无字节数。</p>
<p>函数自身汇编语言如下,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push ebp     保存ebp寄存器，该寄存器将用来保存栈的栈顶指针，可以在函数退出时恢复</span><br><span class="line">mov ebp,esp  保存栈指针</span><br><span class="line">mov  eax,[ebp + 8H]  栈中ebp指向位置之前依次保存有ebp,cs:eip,a,b,ebp +8指向a</span><br><span class="line">add eax,[ebp + 0CH]  栈中ebp + 12处保存了b</span><br><span class="line">mov  esp,ebp         恢复esp</span><br><span class="line">pop ebp</span><br><span class="line">ret         注意，这里没有修改栈</span><br></pre></td></tr></table></figure>



<h2 id="fastcall"><a href="#fastcall" class="headerlink" title="fastcall"></a>fastcall</h2><p>改调用与stdcall类似：</p>
<ul>
<li>函数的第一个和第二个DWORD参数（或者尺寸更小的）通过ecx和edx传递，其他参数通过从右向左的顺序压栈</li>
<li>被调用函数清理栈</li>
<li>函数名修改规则同stdcall</li>
</ul>
<h2 id="thiscall"><a href="#thiscall" class="headerlink" title="thiscall"></a>thiscall</h2><p>thiscall是唯一一个不能明确指明的函数修饰，因为thiscall不是关键字。它是C++类成员函数缺省的调用约定。由于成员函数调用还有一个this指针，因此必须特殊处理，thiscall意味着：</p>
<ul>
<li>参数从右向左入栈</li>
<li>如果参数个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压栈后被压入栈。</li>
<li>对参数个数不定的，调用者清理栈，否则函数自己清理栈</li>
</ul>
<p><strong>(由于此调用约定仅适用于 C++，因此它没有 C 名称修饰方案。)</strong></p>
<h2 id="vectorcall"><a href="#vectorcall" class="headerlink" title="vectorcall"></a>vectorcall</h2><p>vectorcall 继承于fastcall 但对于fastcall中的整数仍然按照fastcall规则传递 而浮点以及向量将通过寄存器传递</p>
<h2 id="nakedcall"><a href="#nakedcall" class="headerlink" title="nakedcall"></a>nakedcall</h2><p>编译器不会给这种函数增加初始化和清理代码，更特殊的是，你不能用return返回返回值，只能用插入汇编返回结果。这一般用于实模式驱动程序设计。</p>
<h2 id="pascal"><a href="#pascal" class="headerlink" title="__pascal"></a>__pascal</h2><p>唯一一个从左到右入栈的约定</p>
<h2 id="函数调用约定导致的常见问题"><a href="#函数调用约定导致的常见问题" class="headerlink" title="函数调用约定导致的常见问题"></a>函数调用约定导致的常见问题</h2><p>如果定义的约定和使用的约定不一致，则将导致栈被破坏，导致严重问题，下面是两种常见的问题：</p>
<ol>
<li>函数原型声明和函数体定义不一致</li>
<li>DLL导入函数时声明了不同的函数约定（所以不能口是心非，会出大问题。）</li>
</ol>
<p>贴一个微软的对此的解释<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-170">函数调用约定</a>。</p>
<p>再贴一篇关于从汇编语言角度对参数传递的理解的博客<a target="_blank" rel="noopener" href="https://blog.csdn.net/magic_world_wow/article/details/80582144"> 从汇编角度看函数参数传递—汇编函数参数</a></p>
<h1 id="Java相关"><a href="#Java相关" class="headerlink" title="Java相关"></a>Java相关</h1><h2 id="native关键字"><a href="#native关键字" class="headerlink" title="native关键字"></a>native关键字</h2><p>native 用来修饰方法，用 native 声明的方法表示告知 JVM 调用，该方法在外部定义，我们可以用任何语言去实现它。 简单地讲，一个native方法就是一个 Java 调用非 Java 代码的接口。</p>
<p>native 语法：</p>
<p>　　①、修饰方法的位置必须在返回类型之前，和其余的方法控制符前后关系不受限制。</p>
<p>　　②、不能用 abstract 修饰，也没有方法体，也没有左右大括号。</p>
<p>　　③、返回值可以是任意类型</p>
<h2 id="System-LoadLibrary-加载图书馆（bushi"><a href="#System-LoadLibrary-加载图书馆（bushi" class="headerlink" title="System.LoadLibrary(加载图书馆（bushi )"></a>System.LoadLibrary(加载图书馆（bushi )</h2><p>该函数的作用：将指定的模块加载到调用进程的地址空间中。指定的模块可能会导致其他模块被加载。对于其他加载选项，请使用 LoadLibraryEx函数。Ex(extra-额外的)—-总的来说，装载库文件。与之<strong>类似</strong>的还有System.load</p>
<p>下面对这两个相似的函数做个解析：</p>
<ol>
<li>它们都可以用来装载库文件，不论是JNI库文件还是非JNI库文件。在任何本地方法被调用之前必须先用这个两个方法之一把相应的JNI库文件装载。</li>
<li>System.load 参数为库文件的绝对路径，可以是任意路径。<br>例如你可以这样载入一个windows平台下JNI库文件：<br>System.load(“C:&#x2F;&#x2F;Documents and Settings&#x2F;&#x2F;TestJNI.dll”);。</li>
<li>System.loadLibrary 参数为库文件名，不包含库文件的扩展名。<br>例如你可以这样载入一个windows平台下JNI库文件<br>System. loadLibrary (“TestJNI”);</li>
</ol>
<h2 id="Biginteger"><a href="#Biginteger" class="headerlink" title="Biginteger"></a>Biginteger</h2><p>在Java中，由CPU原生提供的整型最大范围是64位<code>long</code>型整数。使用<code>long</code>型整数可以直接通过CPU指令进行计算，速度非常快。</p>
<p>如果我们使用的整数范围超过了<code>long</code>型怎么办？这个时候，就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code>就是用来表示任意大小的整数。<code>BigInteger</code>内部用一个<code>int[]</code>数组来模拟一个非常大的整数</p>
<p>此处仅作简单介绍，详细了解参考如下的教程网站<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1279767986831393">Bitinteger</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2298233831.github.io/2021/12/18/Weekly-Study1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yu4n">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Blog of Yu4n">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/18/Weekly-Study1/" class="post-title-link" itemprop="url">Weekly Study</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-18 19:25:04" itemprop="dateCreated datePublished" datetime="2021-12-18T19:25:04+08:00">2021-12-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 22:11:45" itemprop="dateModified" datetime="2022-01-05T22:11:45+08:00">2022-01-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Weekly-Study"><a href="#Weekly-Study" class="headerlink" title="Weekly Study"></a>Weekly Study</h1><p>（本周由于“积极”备考，所以书看的比较少，稍微写写做题中遇到的一些问题吧。）</p>
<ol>
<li><p>迷宫题</p>
<p>由于之前在攻防世界练过一道迷宫题，simple的8和14也没有停顿太久</p>
<p>这类题的关键就在与搞清“怎么走”—迷宫图的正确画出是关键，其次是按钮控制的方向。这些都需要结合具体函数进行判断。</p>
<p>以simple8为例</p>
<p><img src="/2021/12/18/Weekly-Study1/image-20211219174148388.png" alt="image-20211219174148388"></p>
</li>
</ol>
<p>可以猜测，本题迷宫又1152个字符构成，且可组成每行60字符，共19行的迷宫</p>
<p>故先打印处整体的迷宫(实际是1140个字符)</p>
<p><img src="/2021/12/18/Weekly-Study1/image-20211219180035314.png" alt="image-20211219180035314"></p>
<p><img src="/2021/12/18/Weekly-Study1/image-20211219181223256.png" alt="image-20211219181223256"></p>
<p>规则如上代码，s为起点，t为终点，移动方式为经典WASD，按图走出即可。</p>
<p>总结：画图和移动规则是关键。</p>
<ol start="2">
<li><p>关于反调试</p>
<p>对反调试稍微看了一下，主要参考以下文章<a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/others-articles/181085.html">Windows下反反调试技术汇总 - FreeBuf网络安全行业门户</a>，此次不做总结（还没看完，暂时停留在静态反调试技术。）</p>
</li>
<li><p>然后就是simple7的爆破法，(头一次用，当时还没看明白学长们的range(33(31开始也可以),127)是啥意思，其实就是ASCII码表对应的可见字符。)</p>
</li>
<li><p>最后就是继续学了一点汇编，其余的时间都在复习四级了。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yu4n</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yu4n</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
